# 网络层
## 网络层互连一般形式

![网络层互连一般形式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络层互连一般形式.png)

上图是网络层互连的一般形式，每个大学的每个系通过局域网进行互连，然后在单个大学中各个院系的局域网通过交换机(网桥)完成连接。在大学与大学之间通过广域网的点对点的形式进行互连。

![网络常用互联设备](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络常用互联设备.png)

上图是网络常用的互连设备，第一层和第二层上一章介绍过。第三层的路由器是用在远距离通信上，是点对点传输，可以容纳多个协议，支持在不同网络之间转发数据包。

![网络常用互联设备四五层](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络常用互联设备四五层.png)

上图是网络四五层常用的互连设备。

## 路由器(Router)
### 广域网连接
* 因为整个广域网覆盖范围较广，在整个广域网上实现广播是不可能的，因此需要进行路由选择点对点的形式。

![广域网互连](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.广域网互连.png)

上图是典型的广域网中的节点互连，中间的是路由器。路由器来选择点对点的最短路径完成连接。

### 路由器
* 路由器：是一种用来连接两个运行相同/不同协议的通信子网的硬件设备，其工作在网络层。
* 特性
	* 一种用于连接两个运行相同/不同协议的中间系统
	* 针对网络层地址协议(如IP地址)进行选择和判断
	* 需要有二层地址与三层地址的映射能力(地址解析)
	* 对相同高层协议提供多个网络的互连服务

![路由器工作](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由器工作.png)

上图是路由器的工作示意，路由器(R1,R2,R3,R4)的每个端口连接一个通信子网，各个通信子网间可以采用不同的协议。路由器间可以协同工作，为处于各个子网的主机间的通信寻找到一条最短路径。注意：子网间的协议可以不同，路由器可以跨协议传输。

### 路由器和网桥的区别
* 网桥工作在主机-网络层

![网桥协议栈](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网桥协议栈.png)

* 路由器工作在网络层

![路由器协议栈](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由器协议栈.png)

* 网桥的数据处理的单位是帧
	* 网桥针对接收到的每一个数据帧，只检查帧头，并不检查或者修改帧包含的上层(网络层)的包。
	* 网桥不知道/也不需要知道帧中所使用的协议
* 路由器的数据处理单位是包
	* 检查每个包的包头，并根据包头包含的目标地址做出路由决策
	* 当将包交给下层数据链路层(网卡)转发，由网卡将包分装在以太帧或非以太帧中。

## 网络互连面临的问题

![网络互连面临问题1](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络互连面临问题1.png)

上面列出来的问题主要是因为连个局域子网之间有可能采用的协议不同导致数据传输的方式不同引发的问题。

![网络互连面临问题2](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络互连面临问题2.png)

上面是网络互连面临的其他类型的问题。

### 解决网络层各协议包长度不同问题
* 包的长度在传输的时候受到限制(数据报文被切割成为数据包)
	* 硬件的限制
	* 操作系统的局限
	* 协议设定
	* 减少由差错引发的重传
	* 防止某个包占用信道时间过长
* 分段技术：将大的包分成为网络能容纳的一系列段，将每一段作为一个独立的包发送。

#### 分段技术
##### 透明分段
* 透明分段：将数据包进入网络时按需分段，离开网络时恢复原样，使得前面的分段对后边的网络透明。

![透明分段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.透明分段.png)

上图为透明分段的示例，根据每个子网采用的不同协议将数据包在入境的时候在网关中划分成为不同大小的包(段)进行传输，在出境的时候再次由网关合并成为原始的数据包交给下一个子网。

* 透明分段策略特点
	* 出口网关必须确定何时收到全部小包
	* 所有小包必须经同一个网关离开网络
	* 不断地分段与重组会增大网关开销
* 如果拆分的小包走了不同的路径，结果抵达不同出口的网关，将无法重组还原出原始包。

![透明分段的局限](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.透明分段的局限.png)

如上图，G6和G2都是出境的网关，如果一部分被分割的小包走的G2出境，一部分小包走的G6出境，两个网关所合并的数据包都不是原始完整的。

##### 不透明分段
* 不透明分段：任一中间网关都不重组，必要时只进行分段，仅在目标主机中进行一次重组。

![不透明分段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.不透明分段.png)

如图是不透明分段的工作过程，只在必要时入境的时候进行分段，但是在包出境的时候不进行重组。只有在最终数据包传输终点的时候进行重组。任何主机都可能是终点，所以要求每个主机都能重组。重组的时候开销大，因为包被多次切割成较小的块。

##### 重组
* 一般采用树形结构编号，按照编号组成合成原始包

![按照树形结构编号的子包](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.按照树形结构编号的子包.png)

如图是按照树形结构编号的子包，当采用透明分段方法只有两层的树，因为每次切割后都要再进行一次重组，最多只有两层的树。而非透明分段方法在传输过程中可能需要多次的分割，可能产生多层。最终按照编号进行重组。

### 隧道互连技术
* 隧道：在两个端点建立传输数据报的虚拟管道，使所传输的数据报不为途径的节点所知，通常采用封装技术。

![隧道技术](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.隧道技术.png)

上图为隧道互连技术，为两个端点建立了一个用于传输数据报的虚拟管道，这个管道不被途径的节点所知，数据报不会被途经节点处理，直接到达目标节点。

## 网络层功能、作用以及服务

### 端对端通信
* 端对端通信:两个计算机系统传输实体之间的通信。
	* 网络层在其与传输层的接口为传输层提供服务。
	* 网络层是处理端对端数据传输的最底层。

![端对端通信](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.端对端通信.png)

![端对端通信内部结构](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.端对端通信内部结构.png)

上面两个图为端到端通信示意图，当应用层产生了数据交给传输层，传输层将报文交给网络层，网络层匹配最佳的传输连接，将数据包交给链路传递。

### 网络层作用
* 网络层的作用
	* 接入网络将用户数据报发送因特网
	* 网络核心完成路由选择，由链路层实现每一跳的数据传输
	* 网络层在数据包的传递中起着决定性的作用

![网络层的作用](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络层的作用.png)

* 网络层主要是用于端对端连接。端系统间需要一种命名和一种路由选择机制。
* 路由器沿着目标方向转发数据包。

![网络层的路由选择](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络层的路由选择.png)

上图为网络层的源端到目标端的路径，图中总共有4条路径可选。网络层必须为数据包选择出最好的那条路径。

### 网络层功能
* 网络层的功能
	* 交换/转发
	* 路由选择
	* 拥塞控制

![网络层的功能](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络层的功能.png)

* 路由选择

![路由选择](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由选择.png)

* 连接建立和拥塞控制

![连接建立和拥塞控制](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.连接建立和拥塞控制.png)

### 网络层提供的服务
* 网络层提供的功能
	* 传输层是网络层的服务使用者
	* 传输层通过与网络层的接口把数据交给网络层发送
	* 网络层是传输层的服务提供者
	* 网络层把上层用户数据按照本层协议封装成包
	* 网络层通过与链路层的接口把包传递给下层发送
* 按照不同的连接方式分为
	* 面向连接
		* 当上层用户(本层的服务用户)通过接口把数据向下交给网络层时，网络层要先建立一条鱼目标节点的连接。然后把封装了数据的包往下交给链路层(本层的服务提供者)发送，相当于把包发到了该连接上。
	* 无连接
		* 当上层用户通过接口把数据向下交给网络层时，网络层直接把数据封装成本层的包，往下交给链路层发送。

![网络层服务](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络层服务.png)

上图是网络层提供的服务，网络层之间需要先建立连接再把数据包交给链路层完成传输，是面向连接。而不先完成连接的，直接交给链路层传输的是无连接。

### 网络层的通信模式
* 单播
	* 一对一的通信模式
	* 必须有一套全局唯一的命名规则
	* 每个网络节点有一个唯一的ID
	* 路由器处理包时根据该ID进行路由抉择

![单播](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.单播.png)

* 组播
	* 一对多的通信模式
	* 必须有一套命名一组用户的规则(组播地址)
	* 每个网络节点除有固定唯一的ID，还必须有相应组ID
	* 路由器根据组成员分布将组播包转发到组成员所在子网

![组播](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.组播.png)

* 广播
	* 一对全部的通信模式
	* 必须有一套命名全体用户的规则(广播地址)
	* 每个网络节点除有固定唯一ID外，还有相应的广播ID
	* 路由将广播包发送到一定范围的全部通信子网

![广播](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.广播.png)

注意：在发送方发送数据包的时候，路由需要根据接收方的ID选择一条好的路径完成建立转发数据包。单播的时候不需要将数据包复制为多份，接收方直接接收原始数据包即可。但是组播和广播，在接收的时候需要对原始数据包进行复制，每个接受方都有一份数据包。

## 路由器
### 传输形式
* 在包的传输路径上，每个路由器收到包后，根据包给定的目标地址把包从特定端口转发到路径上的下一站。
* 网络层的包必须被封装在端口锁连网络协议规定的帧中才能真正被发送。
* 路由间的传递数据包的形式是:一跳传输。
* 一跳传输(one hop):指网络传输路径的一次存储-转发。

![一跳传输](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.一跳传输.png)

### 存储与转发

![路由器的存储与转发](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由器的存储与转发.png)

上图是路由器内部结构，存储-转发功能是通过路由表来决定的，路由表根据数据包的目的地址，来选择下一个路由。

* 存储-转发时延:从包进入路由器R算起，到被转发到下一站路由器C所经历的全部时间。
* 存储-转发技术特点
	* 同一端系统之间的包可能走不同的路径
	* 路由器上的路由表决定了包的路径

![路由器的转发](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由器的转发.png)

如图，主机H1给H2发送数据报文。该报文被拆分成4个包传递，根据路由表前三个包选择的最短路径是A-C-E-F,当第4个包转发路径发生变化，因为A-C-E-F最短路径流量拥塞，而选择另一个路径。

* 存储-转发技术的实现
	* 每个包必须包含目标主机地址的完整地址(如IP地址)
	* 路由器上的路由表指出通向目标端的处境路线
	* 当一个包入境时，路由器查找路由表并将包沿出境线路发出，无须修改包中的任何内容。
* 路由表只表明从本地发出入往目标地址的路径。
* 路由表必须及时更新反应网络动态变化情况。

![路由表结构](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由表的结构.png)

上图是路由表的结构。

![路由器的转发路由表变化](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由器的转发路由表变化.png)

如图，以上面的例子为准，当包4传输的时候，路由表发生了变化。注意，这个路由表是A的路由表，出境路线的那个节点是A按照路径给发送的下一个节点路径。例如，目标地址是D，A只能先给B发送再到D，所以当目标节点为D的时候，出境地址为B。

![路由器的转发路由表变化1](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.路由器的转发路由表变化1.png)

如图，是上面例子完整的不同节点的路由表变化。

### 路由算法
* 路由器之间只能通过消息交换获得更多的拓扑和路由信息。
* 网络所采用的路由算法决定了各路由器之间交换怎么样的路由信息。
* 标准
	* 最短路径
	* 最快路径
	* 最可靠路径
	* 最低成本路径
	* 注意:最短路径和最快路径不一定是同一路径，流量也起到了决定作用。
* 静态路由-非自适应算法
	* 不是根据实际测量活估计的网络当前流量和拓扑结构作路由的决策
* 动态路由-自适应算法
	* 根据网络拓扑结构，流量变化来改变其路由选择
	* 前提:节点间交换网络状态信息
		* 信息越多，做出的路由决策越好
		* 信息越多，网络负担越大性能下降越快
	* 优点
		* 可提高网络性能
		* 有助于拥塞控制
	* 缺点
		* 路由决策复杂
		* 依赖于状态信息
		* 不能太快和太慢，太快导致路由抖动，太慢退化成静态路由。
#### 静态路由算法
##### 泛洪路由
* 泛洪法：路由器之间无需交换任何网络状态信息和路由信息，没有路由表，将受到的包转发到所有出境路线(入境路线除外)

![泛洪法示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.泛洪法示例.png)

如图是泛洪发的过程示例，当有数据包到达的时候，会将数据包转发给所有的出境路线。A给BC,B给D，C给E，D给E，E给C，D，F，F出境。有正方向的包传递到了F，也有反方向回传的包，例如E给D,E给C，然后会反方向再次传递。

![泛洪法示例1](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.泛洪法示例1.png)

如图产生的反方向的包，只要网络拓扑结构存在环路，重复包将急剧增多，甚至成指数级的增长。可以通过一些策略来减少重复包增长。例如，记录传输包的传输次数，到达一定次数后可以认定为重复包。记录传输包的传输路径产生环路即为重复包。丢弃掉重复包。

* 泛洪路由特性
	* 尝试所有可能路由
	* 至少有一个包通过最小跳路由到达
	* 所有与源节点连接的节点都被访问
* 优点(与路由特性对应)
	* 具备路由健壮性
	* 发现最好的路径
	* 可用来广播重要的消息。
* 一条健壮的理由对于动态网络中的可靠数据传输非常重要
* 最好的路径是指所有可能路径中性能最好的那条
* 衡量广播通信性能的一个很重要指标是广播包的覆盖率
* 泛洪广播很适合广播重要的信息

##### 最短路径选择法
* 最短路径选择法：每个路由器计算从本地出发到达所有目的的最短路径。根据结果，生成路由表。
* 子网图:节点代表路由器;弧线代表两个路由器之间的一条链路。

![子网图](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.子网图.png)

* 通过对子网图使用Dijkstra算法，找出一个节点到所有其他节点的最短路径。
* 路由度量:一种用来计量路由的标准。可以选择任何一种标准或多个标准的组合来计算从本地出发到所有其他目的地的最短路径。
	* 跳计数:包被路由器转发一次就是使用一跳，边的成本为1
	* 物理距离:两个路由器之间的物理距离作为边的成本
	* 信道带宽:连接两个路由器的链路的信道带宽
	* 平均延迟:两个路由器之间信道的平均延迟
	* 通信成本:连接两个路由器的链路的通信成本

![以跳计数为度量的最短路径](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.以跳计数为度量的最短路径.png)

上图是以跳计数为度量的最短路径，A路由表内容。每一跳产生一个计数。也可以理解为边的权重都为1.

![以距离为度量的最短路径](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.以距离为度量的最短路径.png)

上图是以距离为度量的最短路径。

* 优点:可以根据用户的需求来选择一条最好的路径
* 缺点
	* 必须提前获得全局的网络拓扑信息
	* 必须拥有每条连接两个路由器边的状态信息

##### 两种路由算法的比较
* 泛洪路由
	* 无需任何网络状态信息
	* 可以根据用户需求选择一条最好的路径
* 最短路径路由	
	* 必须事先获得全局的网络拓扑信息
	* 必须拥有每条连接两个链路右边的状态信息
* 所有静态路由算法都无法根据网络状态变化做出动态调整

#### 动态路由算法
##### 链路状态路由算法
* 链路状态路由算法:每个节点都有网络完整拓扑图，每个节点维护到邻居的连通性与链路成本。节点向网络中所有其他节点广播自己和邻居的连接信息，每当接收到来自其他节点信息时用Dijkstra算法重新计算路由表。
* 链路成本:反应路由度量的函数。带宽越高，链路成本越低。

###### 算法过程
1. 链路状态信息的获取
	1. 发现邻居节点:在一跳内广播一个HELLO消息，邻居的Response消息把自己的地址带了进来。
	2. 测量链路成本:给发现的邻居节点发送ECHO消息，邻居节点收到ECHO消息后立即返回，用来测试链路的往返时间(时延)
	3. 封装链路状态包:把本地链路(与邻居相连)成本以及邻居ID封装在一个报文中。
	4. 广播链路状态信息:发送链路状态包
		* 定期发送
		* 出现重大事件发送

![发现邻居节点](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.发现邻居节点.png)

上图是节点A检测自己的邻居，在一跳范围内发送HELLO消息，一跳范围内就是相邻路由器的意思，当邻居路由收到HELLO消息后马上返回一个Response消息，消息中包含自己的地址。

![测量时延](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.测量时延.png)

上图是A测量到B的时延，A发送一个ECHO消息给B，B收到了消息后立刻返回一个Respone消息作为回复，在A收到B的回复消息这段时间作为链路成本时延。

![链路状态包](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路状态包.png)

上图是一个链路状态包的示例，包含了一些包的信息还有邻居节点以及到达邻居节点的链路成本。

2. 链路状态路由计算
	1. 计算新路由
		* 根据接收到的所有节点链路状态包构建表示网络拓扑的子网
		* 采用Dijkstra算法计算从本地到所有其他节点的最短路径
	2. 生成路由表:根据生成的最短路径生成/更新路由表

![生成拓扑子网](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.生成拓扑子网.png)

上图是A节点收到了其他节点发送的链路状态包，然后根据包生成了整个网络的拓扑子网。

* Dijkstra算法
	1. 初始化工作，在子网中标出所有节点到初始节点A的最短距离，只有与A相邻的节点才知道到A的距离。不与A相连标注为无穷大。
	2. 循环迭代，直到找出所有节点到A的最短距离

![Dijkstra路径公式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra路径公式.png)

* Dijkstra示例
0. 网络子网

![原始网络子网](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.原始网络子网.png)

1. 初始化
	* 将A加入到集合N
	* 将A邻居到A的距离标注为链路成本，与A临接的节点B和G到A的最短距离就是链路成本。
	* 标注的形式为(最短距离,起始节点)
	* 注意，不连通的节点距离为无穷。

![Dijkstra示例步骤1](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra示例步骤1.png)

标注了与A相连的B和G的节点，B(2,A) G(6,A)

2. 循环迭代1
	* 选择到A距离最短的节点B加入N
	* 标值其他节点经B到A的距离
	* 注意，这里的最短路径是到A的最短路径，并不是到B节点的。
	* 之前E和C并不跟A连通，所以之前为无穷。

![Dijkstra示例步骤2](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra示例步骤2.png)

选择路径最短的B节点，标注与B相连的E和C节点。E(?,B)= min(∞ ,2 + 2) = E(4,B)
  C(?,B)= min(∞ ,2 + 7) = C(9,B)

3. 循环迭代2
	* 选择到A距离最短的节点E加入N
	* 标值其他节点经E到A的距离
	* 注意，当某节点之前有之前节点到达的最短路径，即被更新过，如果从本节点到达的某节点的最短路径要小，再次更新，同时切换前驱节点。例如本步骤中的G点的前驱节点从A切换到了E，路径也发生变化了啊！！！

![Dijkstra示例步骤3](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra示例步骤3.png)

选择路径最短的E节点，标注与E相连的G和F节点。G(?,?)= min(6,4 + 1) = G(5,E)
  F(?,E)= min(∞ ,4 + 2) = F(6,E)

4. 循环迭代3
	* 选择到A距离最短的节点G加入N
	* 标值其他节点经G到A的距离

![Dijkstra示例步骤4](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra示例步骤4.png)

选择路径最短的G节点，标注与G相连的H节点。H(?,G)= min(∞ ,5 + 4) = G(9,G)

5. 循环迭代4
	* 选择到A距离最短的节点F加入N
	* 标值其他节点经F到A的距离
	* 注意，当从当前节点连通到的最短路径和之前节点状态的连通的最短路径相同的时候不改变。例如本步骤中的C节点

![Dijkstra示例步骤5](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra示例步骤5.png)

选择路径最短的F节点，标注与F相连的H和C节点。H(?,?)= min(9,6 + 2) = G(8,F)
  C(?,?)= min(9 ,6 + 3) = C(9,B).

6. 依次类推
	* 依次加入H,C,D直到所有节点都加入N中。

![Dijkstra示例步骤6](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra示例步骤6.png)

7. 计算最短路径
	* 从任意一个目标节点根据标注倒着往前推即可获得从源节点A到该节点的一条最短路径。

![Dijkstra计算最短路径](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra计算最短路径.png)

* 更新路由表
	* 根据Dijkstra计算出的最短路径来更新路由表
	* 路由表中只记录了离该节点的出境方向，并没有记录完整的路线(下一个节点)，因为没必要记录完整路线。
	* 但是路由表记录了到达该点的路径整体长度，并不是到下一个节点的距离。

![Dijkstra最短路径更新路由表](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.Dijkstra最短路径更新路由表.png)

上图是更新A的路由表，例如从A出发到D的最短路径是A-B-E-F-H-D，整体路径长度为10,所有路由表目标地址为D的那项的出境地址为B，路径长度为10.别的同理。

###### 以链路延迟作为链路成本
* 如果链路成本表示流量负载，那么在通过ECHO消息测量链路成本时就要考虑了网络流量负载。

![网络负载导致权重增加](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.网络负载导致权重增加.png)

上图是不同时刻网络流量负载的不同导致每条线路的权重发生变化，与此同时最短路径也发生了变化。G-H路径因为网络负载权重从4增加到了7。

* 路由震荡：路由随着链路成本的变化来回切换，导致路由不稳定。

* 优点：在相同链路条件下，选择轻负载的路径可以减少排队时延。
* 缺点：可能造成路由来回震荡，更新路径周期不能太快。

##### 链路状态路由算法示例

0. 前提：链路成本和网络状态

![链路路由算法示例1](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路路由算法示例1.png)

1. 发现邻居并测量链路成本

![链路路由算法示例2](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路路由算法示例2.png)

测量结果

![链路路由算法示例3](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路路由算法示例3.png)

2. 生成并发送链路状态包

![链路路由算法示例4](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路路由算法示例4.png)

3. 计算最短路径

![链路路由算法示例5](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路路由算法示例5.png)

4. 生成路由表

![链路路由算法示例6](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.链路路由算法示例6.png)

##### 距离矢量路由算法
* 假设
	* 每个包有完整的目标地址
	* 每个包独立选择下一跳
	* 只能依赖路由表
* 只要路由表的信息是一致的和完备的，按照路由表转发包就一定能将包传递到目的地，而且这是一条最好的路径。
* 基本思想:只要一个节点不是孤立点，就可以通过和邻居交换路由信息来获取网络的全部路由信息。
* 特点
	* 分布的:通过和邻居交换路由信息来计算网络路由
		* 每个节点接收来自与其直接邻节点的路由信息，并执行路由计算
		* 将计算结果回传给直接邻接节点
	* 迭代的:当各节点路由稳定后，算法收敛
		* 计算过程循环进行
		* 直到相邻节点没有可交换的路由信息为止
	* 异步的:各个路由独立运行路由算法
		* 并不要求所有节点相互锁步操作

###### 算法过程
1. 计算距离

![距离矢量算法计算距离](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.距离矢量算法计算距离.png)

上图是距离矢量算法计算距离的公式，我们计算从X到Y的距离，从X到Y必须要途径Z节点。所以需要X到Z的距离加上Z到Y的最短距离，Z到Y的最短距离并不用再去计算，由Z节点直接提供。所以X节点直接跟Z节点交换信息就可以计算从X开始途径Z到Y的最短距离。

2. 计算距离矩阵

![距离矢量算法计算距离矩阵](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.距离矢量算法计算距离矩阵.png)

上图是计算的E的距离矩阵，E节点的邻居节点是A、B和D。要想去往别的节点必须要途径这三个节点之一。最左边的是目标，也就是所要去的终点。我们计算从E开始经过A到达D的距离。最短距离为 E-A-E-D = 4.注意这里算的最短距离是可以回退的，也就是因为途径A为前提，可以先从E到A然后从A再回退到E再到D。依次类推，计算出途径所有邻居节点到各个节点的最短距离表。

3. 生成路由表

![距离矢量算法生成路由表](https://github.com/zzhangyuhang/computer-network/blob/master/photo/5.距离矢量算法生成路由表.png)

上图是生成路由表的过程。我们看计算出来的整个距离表，每个横排就是到到目标节点的途径邻居节点的所有最短路径。选择其中最短的那条，就是最短路径，方向(出境路线)是经过的邻居节点。

###### 数据结构
* 每个节点维护一张经过所有邻居到全部目的地的距离表(距离矩阵)
* 节点信息资源
	* 与其直接相连的链路(本地链路)的成本
	* 来自邻接点的路由信息
	* 计算从本地触发到达所有目的地的全部可达路径需要本地链路信息和邻居节点的路由信息
* 距离矢量算法
	* 用估算延迟作为性能指标
	* 基于Bellman-Ford算法
* 在节点状态发生改变的时候(增删节点/距离变化)需要重新迭代分发路由信息。变化的节点先分发给邻居节点，邻居节点根据变化来更新自己的路由信息(最短路径信息)，如果需要更新则更新，且将更新的路由信息发送给自己的邻居。如果没有发生变化，则不需要经过以上步骤。


##### 链路状态与距离矢量路由算法的比较
* 算法复杂性
	* 链路状态
		* 发送的链路状态包量级
		* 只要一条露露成本发生变化，新链路成本必须通过所有节点
	* 距离矢量
		* 每次迭代相邻节点交换信息(目的地，路径长度)
		* 只有在新链路成本影响到该链路上节点的最小成本时才会重新计算分发路由
* 成本和消耗
	* 链路状态
		* 无论周期性的广播链路成本还是链路成本发生变化时发布更新的链路成本，对网络带宽的都是很大的小号
	* 距离矢量
		* 只在路由计算结果发生变化时才将路由通知给邻居，这种路由包仅在一跳范围内扩散，网络带宽消耗小。
* 消息传播速度
	* 链路状态
		* 为了可靠性，一般采用广播的方式
			* 每条链路成本被两边的节点各发送一次
			* 每条链路成本被所有的节点要转发一次
	* 距离矢量
		* 好消息传播的快，坏消息传播的慢
			* 好路径的出现通过逐跳转发很快扩散到全网
			* 坏路径的出现不仅传播慢而且有可能形成无穷计算问题。
* 健壮性
	* 链路状态，有一定健壮性
		* 出错的情况包括广播的链路成本有错或者本地计算错误，但这种错误只影响路由器所在的局部区域。
	* 距离矢量，计算错误可能扰乱整个网络
		* 节点通过和邻居节点交换路由信息间接地了解整个网络的状态，一个节点的计算错误可能波及一大片。
