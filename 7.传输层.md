# 传输层

![传输层](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层.png)

上图是传输层的简单示例,网络层传递数据是在于主机和主机包之前进行传递,传输层则是进程和进程之间数据传递,而应用层则是应用和应用之间传递.


## 传输层的需求
* 传输层位置网络层之上,应用层之下,为应用层提供服务.
* 传输层应能同时支持多个网络应用
* 传输层应能检验传输是否出错
* 传输层协议能够提供应用层数据传输质量保证
	* 应用的多路复用/分用服务
	* 可靠的数据传输
	* 带宽以及延迟保证

![传输层传输数据示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层传输数据示例.png)

上图是传输层数据的简单示例,应用层之间传输数据,应用层将数据下交给传输层,传输层建立端到端的逻辑连接,然后下交给网络层进行实际的数据传输.传输目的地同样要经历多层模型之后到达应用层.

## 传输层和网络层的关系
* 网络层提供的是不可靠传输
	* 网络层提供的服务不可靠(丢包和重复)
	* 路由器可能崩溃
	* 传输线路中断
* 当数据传输过程中网络连接中断,传输层可与远程传输实体建立一新的网络连接,在中断处继续数据的传输.
* 传输层可检测到包丢失和损坏乱序等差错情况,采取相应措施
* 传输层服务原语言独立于网络服务原语,因而应用程序可采用标准的传输原语.

![传输层和网络层的关系](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层和网络层的关系.png)

上图是传输层和网络层关系的模拟图.如图所示,北京大学和南京大学相当于主机(端-端连接单位),每个同学相当于一个应用,每个同学将要发送给对面主机的数据交给小明和小芳,小明和小芳相当于传输层.但是小明和小芳也没有实际进行传输,而是再次交给邮递员完成实际的传输,这邮递员就是网络层(IP).邮递员根据实际地址完成真正的传输,就是邮政服务,相当于链路层.

![传输层和网络层的关系解释](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层和网络层的关系解释.png)

* 网络层协议处理主机之间通信的事务
* 传输层协议处理应用进程之间通信的事务

![传输层和网络层的协议关系](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层和网络层的协议关系.png)

上图是传输层和网络层协议之间的关系,传输层主要的协议有两种:TCP/UDP,同种类型之间的协议可以建立连接.建立连接后网络层协议根据传输层建立的连接建立自己的网络层的连接.

* 传输层提供的服务
	* 传输层协议要解决的问题取决于网络底层所能提供的服务质量
	* 需要解决网络层服务的问题
		* 丢包
		* 出错
		* 顺序混乱
* 传输层可以提供可靠(TCP)和不可靠(UDP)的网络服务
	* 基于可靠有序网络服务
		* 寻址(定位应用程序)
		* 多路复用(为多个应用服务)
		* 流量控制(发送接收匹配)
		* 连接建立/释放
	* 基于不可靠的网络服务
		* 寻址(定位应用程序)
		* 多路复用(为多个应用服务)
		* 流量控制(发送接收匹配)
		* 连接建立/释放
		* 有序传送(保证数据顺序)
		* 重传策略(报文丢失出错后)
		* 重复检测(必须丢失重复报文)
		* 系统崩溃修复

## 传输层的基本功能
* 建立连接
	* 面向连接:通信双方要先建立一条逻辑链路才能开展数据传输业务.大多数面向连接的服务提供了可靠的通信.
		* 流程
			* 建立连接
			* 传输报文
			* 拆除连接
	* 无连接:通信双方无需事先建立连接协商同喜事宜就能直接发送报文.大多数无连接通信是不可靠的.
		* 流程
			* 传输报文
		* 应用领域
			* 内部数据收集
			* 外部数据发布
			* 请求-响应
			* 实时流媒体应用
	* 连接性是传输层向上层用户提供的服务使用方式
	* 可靠数据传输
		* 报文不丢失/不重复/不损坏/不乱序
	* 不可靠数据传输怒
		* 报文可能丢失/可能重复/可能损坏/可能乱序
	* 可靠性是传输层向上层用户提供的服务的质量保障
* 分用:当传输层从网络层接收数据后,必须将数据正确递交给某个应用程序.
* 复用:当传输层从应用程序接收报文后要封装在传输层的段中再交给网络层发送.
* 差错检验和差错控制:传输层举报检验所传报文是否出错并实行控制的能力
	* 差错检验
		* 给报文标号
		* 设置超时计时器
		* 序号检测和计时器超时
	* 差错控制
		* 报文丢失(超时机制)
		* 报文重复(序号检测)
		* 报文损坏(计算校验和)
		* 报文乱序(顺序检测)
	* 差错控制是数据传输可靠性保障的基础
	* 差错控制是传输服务质量保证的前提
* 流量控制和拥塞控制
	* 流量控制:发送方和接收方的计算\缓存和收发能力不一致都将造成报文发送和接收在速度上的差异.对象是两端进程
	* 拥塞控制:网络总任何一个区域的报文转发不畅都有可能造成报文丢失/时延过长,任其发展后果严重.对象是整个网络.

### 应用接口与传输层的多路复用
#### 应用接口Socket与端口号
* socket:应用进程进行端到端通信时访问传输层的软件接口
* 使用socket的通信过程
	* 应用程序发送时将数据放入socket
	* 应用程序接收时从socket提取数据
	* 收发主机任意时刻可有多个socket

![socket通信示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.socket通信示例.png)

上图是socket通信示例.传输层具有两种类型的socket:TCP/UDP,不相同协议之间不能进行传输数据.传输层实体可同时支持多个应用程序,传输层实体将网络层传来的数据正确分发给C1/C2或者S1/S2.

那么如何来区分进程呢?

* 端口号:用来表示某个特定的应用进程的ID.
* 端口的作用
	* 应用层通过端口将数据交给传输层发送
	* 传输层通过端口将数据交给应用层
	* 端口号仅本地有效
* 端口号是socket的一部分
* socket通过端口号唯一标识了一个应用进程
* 每个报文必须有字段描述传递数据的socket

#### 传输层报文概念格式

![传输层报文格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层报文格式.png)

上图是传输层报文格式.

* Source Port:源端口号,指明了发送报文的应用进程
* Dest Port:目标端口号,指明了接收报文的应用程序
* Other Header Fields:其他头字段,包含传输层协议控制信息
* Application Data:应用数据,就是传输层报文的有效载荷

#### 数据单元的封装

![传输层报文分装](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层报文封装.png)

上图是传输层报文封装过程,在传输层数据封装在传输层的报文中,报文指明了目标地址的端口号.然后传输层的报文被封装在网络层的IP包中,包中指明了目标的协议地址也就是IP地址.IP包在连路程被封装到数据帧中,并指明了MAC地址.

#### 无连接的多路复用和分用
* 无连接socket:由二元组标识<Dest.IPaddr,Dest.Port#>
* 如果两个具有同一目标IP地址和目标port好的报文将通过同一目标socket到达相同目标进程.

![无连接的报文传递](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.无连接的报文传递.png)

上图是面向无连接的报文传递示意,客户机先向socket请求发送消息,socket会把当前空闲最小端口分配给客户机,客户机通过分配的端口和目标IP和目标端口定点发送数据.在发送数据前并不用事先告知服务器,也就是不用建立连接就直接发送了.当服务器进程收到了数据后会返回给客户机一个响应报文.

* 重复型客户机/服务器模型:服务器在任何时刻只能为一个客户服务.
* 重复型客户机/服务器模型结构
	* 服务器端进程一直处于监听状态,当有请求就能够进行处理
	* 服务端只有一个端口服务所有客户
	* 在服务端有一个请求队列,当同时到达多个请求时,服务器进程也只能一个一个处理,未得到处理的客户端进程在请求队列中排队等待
* 重复型客户机/服务模型特点
	* 等待一个客户请求的到来
	* 处理客户请求
	* 发送响应客户

![无连接的重复型客户机服务器模型](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.无连接的重复型客户机服务器模型.png)

上图是无连接的重复型客户机服务器模型,有三个客户机发送请求给服务器.但是服务器只有一个进程处理请求.

#### 面向连接的多路复用和分用
* 面向连接的socket:由四元组标识<Source Addr,Source Port#,Dest.Addr,Dest.Port#>
* 两个具有同一目标和目标端口号的报文将分配到不同的socket
* 每个socket与一个进程关联
* 服务器同时支持多个socket

![连接的报文传递](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.连接的报文传递.png)

* 并发型客户机/服务器模型:服务器可以同时为多个客户机服务.
* 传输层根据socket的四元组将来自网络层的数据包分用到相应的socket
* 服务特点
	* 服务器等待客户机请求的到来
	* 每到一个请求便启动一个新的服务器
		* 新服务器处理该客户的全部请求
		* 处理结束后终止该服务器

![有连接的并发型客户机服务器模型](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.有连接的并发型客户机服务器模型.png)

上图是有连接的并发型客户机服务器模型,服务器有一个端口负责引导到来的请求,每新来一个请求引导端口进程就为该进程分配一个新的端口来处理该请求,,每个客户都有自己对应的服务器,服务器需要多个端口同时为客户服务.

##### 面向连接的多路复用过程

![面向连接的多路复用过程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.面向连接的多路复用过程.png)

上图是面向连接的多路复用过程,在面向连接和无连接的不同点就是面向连接在进行数据通信之间需要进行连接,服务器最先创建一个迎宾端口来处理请求,客户机最先要发送一个连接请求.当服务器能够建立连接时回复一个响应消息.

![面向连接的多路复用具体流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.面向连接的多路复用具体流程.png)

上图是面向连接的多路复用具体流程.最开始服务器先建立一个迎宾端口等待客户机的连接请求.客户机创建通信端口请求建立连接.客户机的通信端口发送请求连接给服务器的迎宾端口,迎宾端口分配一个新的通信端口用于数据通信与客户端建立连接.连接建立完毕后,客户端和服务器通过刚才建立的连接进行数据通信.

* 讲了这么多什么叫做多路复用和分用呢?
	* 多路复用是多个应用程序通过socket把数据来交给传输层协议来完成传输
	* 多路分用是传输结束后通过socket对应的端口号把不同的数据交给不同的应用程序