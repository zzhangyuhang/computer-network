# 传输层

![传输层](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层.png)

上图是传输层的简单示例,网络层传递数据是在于主机和主机包之前进行传递,传输层则是进程和进程之间数据传递,而应用层则是应用和应用之间传递.


## 传输层的需求
* 传输层位置网络层之上,应用层之下,为应用层提供服务.
* 传输层应能同时支持多个网络应用
* 传输层应能检验传输是否出错
* 传输层协议能够提供应用层数据传输质量保证
	* 应用的多路复用/分用服务
	* 可靠的数据传输
	* 带宽以及延迟保证

![传输层传输数据示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层传输数据示例.png)

上图是传输层数据的简单示例,应用层之间传输数据,应用层将数据下交给传输层,传输层建立端到端的逻辑连接,然后下交给网络层进行实际的数据传输.传输目的地同样要经历多层模型之后到达应用层.

## 传输层和网络层的关系
* 网络层提供的是不可靠传输
	* 网络层提供的服务不可靠(丢包和重复)
	* 路由器可能崩溃
	* 传输线路中断
* 当数据传输过程中网络连接中断,传输层可与远程传输实体建立一新的网络连接,在中断处继续数据的传输.
* 传输层可检测到包丢失和损坏乱序等差错情况,采取相应措施
* 传输层服务原语言独立于网络服务原语,因而应用程序可采用标准的传输原语.

![传输层和网络层的关系](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层和网络层的关系.png)

上图是传输层和网络层关系的模拟图.如图所示,北京大学和南京大学相当于主机(端-端连接单位),每个同学相当于一个应用,每个同学将要发送给对面主机的数据交给小明和小芳,小明和小芳相当于传输层.但是小明和小芳也没有实际进行传输,而是再次交给邮递员完成实际的传输,这邮递员就是网络层(IP).邮递员根据实际地址完成真正的传输,就是邮政服务,相当于链路层.

![传输层和网络层的关系解释](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层和网络层的关系解释.png)

* 网络层协议处理主机之间通信的事务
* 传输层协议处理应用进程之间通信的事务

![传输层和网络层的协议关系](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层和网络层的协议关系.png)

上图是传输层和网络层协议之间的关系,传输层主要的协议有两种:TCP/UDP,同种类型之间的协议可以建立连接.建立连接后网络层协议根据传输层建立的连接建立自己的网络层的连接.

* 传输层提供的服务
	* 传输层协议要解决的问题取决于网络底层所能提供的服务质量
	* 需要解决网络层服务的问题
		* 丢包
		* 出错
		* 顺序混乱
* 传输层可以提供可靠(TCP)和不可靠(UDP)的网络服务
	* 基于可靠有序网络服务
		* 寻址(定位应用程序)
		* 多路复用(为多个应用服务)
		* 流量控制(发送接收匹配)
		* 连接建立/释放
	* 基于不可靠的网络服务
		* 寻址(定位应用程序)
		* 多路复用(为多个应用服务)
		* 流量控制(发送接收匹配)
		* 连接建立/释放
		* 有序传送(保证数据顺序)
		* 重传策略(报文丢失出错后)
		* 重复检测(必须丢失重复报文)
		* 系统崩溃修复

## 传输层的基本功能
* 建立连接
	* 面向连接:通信双方要先建立一条逻辑链路才能开展数据传输业务.大多数面向连接的服务提供了可靠的通信.
		* 流程
			* 建立连接
			* 传输报文
			* 拆除连接
	* 无连接:通信双方无需事先建立连接协商同喜事宜就能直接发送报文.大多数无连接通信是不可靠的.
		* 流程
			* 传输报文
		* 应用领域
			* 内部数据收集
			* 外部数据发布
			* 请求-响应
			* 实时流媒体应用
	* 连接性是传输层向上层用户提供的服务使用方式
	* 可靠数据传输
		* 报文不丢失/不重复/不损坏/不乱序
	* 不可靠数据传输怒
		* 报文可能丢失/可能重复/可能损坏/可能乱序
	* 可靠性是传输层向上层用户提供的服务的质量保障
* 分用:当传输层从网络层接收数据后,必须将数据正确递交给某个应用程序.
* 复用:当传输层从应用程序接收报文后要封装在传输层的段中再交给网络层发送.
* 差错检验和差错控制:传输层举报检验所传报文是否出错并实行控制的能力
	* 差错检验
		* 给报文标号
		* 设置超时计时器
		* 序号检测和计时器超时
	* 差错控制
		* 报文丢失(超时机制)
		* 报文重复(序号检测)
		* 报文损坏(计算校验和)
		* 报文乱序(顺序检测)
	* 差错控制是数据传输可靠性保障的基础
	* 差错控制是传输服务质量保证的前提
* 流量控制和拥塞控制
	* 流量控制:发送方和接收方的计算\缓存和收发能力不一致都将造成报文发送和接收在速度上的差异.对象是两端进程
	* 拥塞控制:网络总任何一个区域的报文转发不畅都有可能造成报文丢失/时延过长,任其发展后果严重.对象是整个网络.

### 应用接口与传输层的多路复用
#### 应用接口Socket与端口号
* socket:应用进程进行端到端通信时访问传输层的软件接口
* 使用socket的通信过程
	* 应用程序发送时将数据放入socket
	* 应用程序接收时从socket提取数据
	* 收发主机任意时刻可有多个socket

![socket通信示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.socket通信示例.png)

上图是socket通信示例.传输层具有两种类型的socket:TCP/UDP,不相同协议之间不能进行传输数据.传输层实体可同时支持多个应用程序,传输层实体将网络层传来的数据正确分发给C1/C2或者S1/S2.

那么如何来区分进程呢?

* 端口号:用来表示某个特定的应用进程的ID.
* 端口的作用
	* 应用层通过端口将数据交给传输层发送
	* 传输层通过端口将数据交给应用层
	* 端口号仅本地有效
* 端口号是socket的一部分
* socket通过端口号唯一标识了一个应用进程
* 每个报文必须有字段描述传递数据的socket

#### 传输层报文概念格式

![传输层报文格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层报文格式.png)

上图是传输层报文格式.

* Source Port:源端口号,指明了发送报文的应用进程
* Dest Port:目标端口号,指明了接收报文的应用程序
* Other Header Fields:其他头字段,包含传输层协议控制信息
* Application Data:应用数据,就是传输层报文的有效载荷

#### 数据单元的封装

![传输层报文分装](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.传输层报文封装.png)

上图是传输层报文封装过程,在传输层数据封装在传输层的报文中,报文指明了目标地址的端口号.然后传输层的报文被封装在网络层的IP包中,包中指明了目标的协议地址也就是IP地址.IP包在连路程被封装到数据帧中,并指明了MAC地址.

#### 无连接的多路复用和分用
* 无连接socket:由二元组标识<Dest.IPaddr,Dest.Port#>
* 如果两个具有同一目标IP地址和目标port好的报文将通过同一目标socket到达相同目标进程.

![无连接的报文传递](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.无连接的报文传递.png)

上图是面向无连接的报文传递示意,客户机先向socket请求发送消息,socket会把当前空闲最小端口分配给客户机,客户机通过分配的端口和目标IP和目标端口定点发送数据.在发送数据前并不用事先告知服务器,也就是不用建立连接就直接发送了.当服务器进程收到了数据后会返回给客户机一个响应报文.

* 重复型客户机/服务器模型:服务器在任何时刻只能为一个客户服务.
* 重复型客户机/服务器模型结构
	* 服务器端进程一直处于监听状态,当有请求就能够进行处理
	* 服务端只有一个端口服务所有客户
	* 在服务端有一个请求队列,当同时到达多个请求时,服务器进程也只能一个一个处理,未得到处理的客户端进程在请求队列中排队等待
* 重复型客户机/服务模型特点
	* 等待一个客户请求的到来
	* 处理客户请求
	* 发送响应客户

![无连接的重复型客户机服务器模型](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.无连接的重复型客户机服务器模型.png)

上图是无连接的重复型客户机服务器模型,有三个客户机发送请求给服务器.但是服务器只有一个进程处理请求.

#### 面向连接的多路复用和分用
* 面向连接的socket:由四元组标识<Source Addr,Source Port#,Dest.Addr,Dest.Port#>
* 两个具有同一目标和目标端口号的报文将分配到不同的socket
* 每个socket与一个进程关联
* 服务器同时支持多个socket

![连接的报文传递](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.连接的报文传递.png)

* 并发型客户机/服务器模型:服务器可以同时为多个客户机服务.
* 传输层根据socket的四元组将来自网络层的数据包分用到相应的socket
* 服务特点
	* 服务器等待客户机请求的到来
	* 每到一个请求便启动一个新的服务器
		* 新服务器处理该客户的全部请求
		* 处理结束后终止该服务器

![有连接的并发型客户机服务器模型](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.有连接的并发型客户机服务器模型.png)

上图是有连接的并发型客户机服务器模型,服务器有一个端口负责引导到来的请求,每新来一个请求引导端口进程就为该进程分配一个新的端口来处理该请求,,每个客户都有自己对应的服务器,服务器需要多个端口同时为客户服务.

##### 面向连接的多路复用过程

![面向连接的多路复用过程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.面向连接的多路复用过程.png)

上图是面向连接的多路复用过程,在面向连接和无连接的不同点就是面向连接在进行数据通信之间需要进行连接,服务器最先创建一个迎宾端口来处理请求,客户机最先要发送一个连接请求.当服务器能够建立连接时回复一个响应消息.

![面向连接的多路复用具体流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.面向连接的多路复用具体流程.png)

上图是面向连接的多路复用具体流程.最开始服务器先建立一个迎宾端口等待客户机的连接请求.客户机创建通信端口请求建立连接.客户机的通信端口发送请求连接给服务器的迎宾端口,迎宾端口分配一个新的通信端口用于数据通信与客户端建立连接.连接建立完毕后,客户端和服务器通过刚才建立的连接进行数据通信.

* 讲了这么多什么叫做多路复用和分用呢?
	* 多路复用是多个应用程序通过socket把数据来交给传输层协议来完成传输
	* 多路分用是传输结束后通过socket对应的端口号把不同的数据交给不同的应用程序

### 连接的建立与释放
#### 基于可靠网络通信
* 通过'二次握手'方式建立连接
	* 发起连接请求的传输实体向另一方发送同步(SYN)请求
	* 被请求传输实体将该请求排入队列直到传输层用户发出OPEN
* 被请求的传输层实体只能接受连接请求,无权决定是否接受该请求
* 传输层实体将请求转达给上层用户后,等待上层用户的决定,并将决定返回给请求方

![可靠网络的通信建立](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.可靠网络的通信建立.png)

上图是可靠网络通信的建立过程,采用二次握手方式.客户端先发起建立连接请求,在服务器收到该请求后回复一个响应请求(接受/拒绝).因为是可靠的数据传输,并不存请求丢失的情况.注意,服务器传输层只能接收来自客户端的请求,不能决定是否接受/拒绝.而是将请求向上转发给应用层来做决定.

![可靠网络的通信建立状态](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.可靠网络的通信建立状态.png)

上图是可靠网络的通信建立的状态变化.在客户端发送请求连接的SYN后进入SYN SENT状态等待服务器的响应SYN.接收到响应的SYN后进入ESTAB状态,连接建立成功,可以发送/接收数据.服务器启动一个端口用于处理请求的,该端口一直处于LISTEN监听状态,每收到一个请求就转发给上层的应用进行处理,同意建立连接就返回一个SYN,进入ESTAB状态.

* 通过'二次握手'方式释放连接
	* 发起连接终止的传输实体想另一方发送连接终止(FIN)请求
	* 被请求传输实体将请求排入队列直到传输层用户发出Close
* 通常连接是双向的,一方发出FIN后,能否继续接受对方发来的数据由具体协议规定.

![可靠网络的通信释放](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.可靠网络的通信释放.png)

上图是可靠网络通信的释放过程,同样是采用了二次握手的方式.

![可靠网络的通信释放状态](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.可靠网络的通信释放状态.png)

上图是可靠网络的通信释放状态的变化过程.客户端发送FIN断开连接请求后进入FIN WAIT状态等待服务器回应.服务器收到FIN请求后向上层应用转发请求进入CLOSE WAIT状态.上层用户同意关闭后发送FIN报文响应,关闭连接.

* 通常在连接释放的时候采用的是对称方式,终止是在两个方向上进行的.
	* 终止连接后不能发数据但能接受数据(只允许接受,不允许发送)
	* 只有在双方均终止连接后连接才算彻底终止

#### 基于不可靠网络通信
* 不可靠网络通信时可能会发生的错误
	* 连接发起方的请求SYN丢失
	* 连接接收方的应答SYN丢失
	* 出现重复的SYN

![不可靠网络的通信重复请求问题](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.不可靠网络的通信重复请求问题.png)

上图是不可靠网络的通信出现的重复数据问题.如图,开始建立连接成功.然后客户机开始传输数据SN0,SN1,SN2.SN0,SN1正常传输,SN2因受链路影响没有正常传输.然后客户机和服务器关闭了本次连接.之后又进行了下次连接,客户端开始传输SN0,SN1,SN2数据.在服务器接收SN2数据前,恰好上次连接SN2数据到达,导致服务器接收了过期的SN2数据丢弃了新的SN2数据.我们可以通过给不同连接不同数据赋予不同的编号来解决这个问题.比如第二次连接发送的数据为SN3,SN4,SN5.这样过期的SN2就不会影响到SN5.

![不可靠网络的通信重复请求问题](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.不可靠网络的通信重复请求问题1.png)

上图是不可靠网络的通信出现的重复请求问题.如图,SYNi是之前被废弃的请求.i是客户机发起本地连接的数据的初始编号.服务器接收了被废弃的SYNi请求,并返回了一个SYNj响应,因此客户机得知服务器返回数据的初始编号为j.正常的客户机连接应为SYNk,服务器丢弃了SYNk请求.现在双方都认为建立了合法连接.客户端发送的数据SNk+1,因为数据编号乱序,拒收SNk+1报文.问题所在:在建立连接的时候没有进行核实确认导致连接出错.每一边都显示确认对方SYN和序号就能解决这个问题.

* 经过核实的连接建立过程就是我们所熟知的三次握手建立过程

![三次握手](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.三次握手.png)

上次是三次握手的建立过程,客户机先发起连接SYNi,服务器收到连接后并请求客户机确认回复SYNj+ACKi.客户机收到回复确认ACKi并确认ACKj.完成连接的建立.当客户机检查ACKi不满足要求的时候会回复一个reject来拒绝本次的连接.

![三次握手释放](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.三次握手释放.png)

上图是三次握手的释放过程,在客户机发起终止连接请求FIN后启动定时器,在一段时间后没有收到来自服务器的ACK后会再次发送,在重试一定次数后自动释放连接.服务器接收终止请求FIN后,对FIN做出相应,并启动关闭定时器,如果回应的ACK并没有得到客户机的回应,查过定时器时间后,连接自动关闭.在客户机收到来自服务器的FIN的ACK后释放连接并返回一个确认ACK给服务器.服务器收到最终的客户机的ACK后释放掉连接.

![三次握手释放客户机回复ACK丢失问题](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.三次握手释放客户机回复ACK丢失问题.png)

上图是三次握手释放客户机回复ACK丢失问题,在客户机释放连接后回复给服务器的ACK报文丢失.因为在服务器收到客户机发来的FIN请求后就设定了定时器,有这个定时器,确认报文丢失不会导致服务器一直处于连接状态,超过定时器的时间后服务器自动释放连接.

![三次握手释放请求FIN丢失问题](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.三次握手释放请求FIN丢失问题.png)

上图是三次握手释放请求FIN丢失问题.在客户机中设立了一个定时器,如果在定时器期间外还没有收到来自服务器的FIN的ACK报文可以认定FIN丢失,自动重发FIN请求.

![三次握手释放请求全丢失问题](https://github.com/zzhangyuhang/computer-network/blob/master/photo/7.三次握手释放请求全丢失问题.png)

上图示三次握手释放请求回复全丢失问题,客户机始终收不到来自服务器的FIN的ACK报文,一直在重发FIN请求.在一定次数后自动释放掉连接.服务器收到了FIN请求,但是服务器一直都收不到FIN的ACK的确认请求,在超过计时器时间自动释放掉连接.