# 图解HTTP
## 了解Web和网络基础
#### Web是建立在Http协议上通信的
* Http是超文本传输协议,协议指规则的约定
* Web使用Http的协议作为规范,完成从客户端到服务器等一系列运作流程.
* 客户端通过指定的访问地址url获取/上传服务器资源.
* 服务器通过使用Http协议与客户端完成资源通信.
* Web的构建采用的是www(万维网)构建技术,包括3部分
	* 超文本标记语言HTML
	* 超文本传输协议HTTP
	* 指定文本所在地址URL

#### HTTP是TCP/IP协议族内部的一个子集
* TCP/IP协议族按层次分别为以下4层
	* 应用层:FTP/DNS/HTTP
	* 传输层:TCP/UDP
	* 网络层:IP
	* 数据链路层

![TCP/IP通信流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.通信流程.png)

#### 与HTTP关系亲密的协议:IP TCP DNS

* IP指的是IP协议族,作用是把各种数据包传送给对方,其中两个重要条件
	* IP地址,可变化
	* MAC地址,基本不会改变
	* 两个地址需要进行配对,才能完成在IP协议上的传输
	* IP间的通信需要依赖MAC地址.采用ARP协议,能完成IP地址解析工作,把知道的目标地址的IP地址解析成为MAC地址,然后完成传输.

![ARP地址解析](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.ARP地址解析.png)

* TCP位于传输层,提供可靠的字节流服务.
	* TCP协议采用三次握手策略,一定会向对方确认是否成功传达
	* 握手过程中使用了TCP的标志:SYN(synchronize)和ACK(acknowledgement)
		* 发送端首先发送一个带SYN标志的数据包给对方
		* 接收端收到后,会传一个带有SYN/ACK标志的数据包以示传达确认信息
		* 发送端再回传一个带ACK标志的数据包,代表握手结束 
	* 若握手过程中莫名中断,TCP协议会再次以相同的顺序发送相同的数据包
	* 除了三次握手,TCP协议还有其他手段保证通信的可靠性

![三次握手](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.三次握手.png)

* DNS提供域名到IP地址之间的解析服务,和HTTP一样位于应用层.
	* 用户经常使用主机名/域名来访问对方计算机,而不是直接由IP地址来访问.
	* DNS协议通过提供的域名查找IP地址,或逆向从IP地址反查域名的服务

![DNS域名解析](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.DNS域名解析.png)

#### HTTP协议通信过程
0. 客户端获取到服务器的域名
1. 通过DNS协议获取到目标域名的IP地址
2. 通过HTTP协议生成目标服务器的请求报文,报文地址是DNS的解析IP地址
3. TCP将HTTP报文分割成多个TCP报文段根据IP地址可靠的传递给服务器
4. IP对TCP报文包进行封装成IP包,通过ARP协议解析出MAC地址进行传输
5. 路由器完成链路选择将IP包准确的传递到目标服务器
6. 服务器收到IP包上交给TCP协议
7. TCP协议将IP包拆解成TCP报文,以原来报文的顺序排序重组
8. TCP协议将恢复的报文上交给HTTP协议进行请求处理
9. 同样运用上述的过程完成请求资源的回传

![HTTP协议通信过程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTP协议通信过程.png)

#### URI是同一的资源描述符,而URL则是URI的子集
* URI是统一资源描述符
	* 规定统一的格式,可方便处理多种不同类型的资源,而不用根据上下文环境来表示资源指定的访问方式
	* 可标识任何东西,不仅是文档文件/图像/服务,也可以是多数的集合体
* URL表示资源的地点,URL是URI的子集.
* 绝对URI格式由7部分构成
	* 协议方案名:不区分大小写,最后必须要附上一个冒号.例如:https:/http:/data:/js:
	* 登录信息(认证)
	* 服务器地址:可以以是DNS可解析的域名,也可以是IPv4/IPv6的IP地址
	* 服务器端口号
	* 带层次的文件路径
	* 查询字符串:?后的查询条件,针对文件路径内的资源,可传入任意数量条件.(可选)
	* 片段标识符(可选)

![绝对URI格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.绝对URI格式.png)

* RFC:指定HTTP协议技术的标准文档.应用程序会按照RFC确定的标准实现.如果应用服务器没有遵照RFC的标准实现,很可能并无法访问.

## 简单的HTTP协议

#### HTTP协议用于客户端和服务器端之间的通信
* 请求访问文本或图像等资源的一端称为客户端
* 提供资源响应的一端称为服务器端
* 一条通信线路上必定有一段是客户端,另一端则是服务器端.两段角色可能互换.
* HTTP能够区分两端的身份
* 请求必定由客户端发出,而服务器端回复响应.肯定先从客户端开始建立通信,服务器端没有收到请求之前是不会发送响应的.

#### 请求报文的组成
* 请求报文的组成
	* 请求方法:GET/POST
	* 请求URI
	* 协议版本
	* 可选的请求首部字段
	* 内容实体

![请求报文构成](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.请求报文构成.png)

#### 响应报文的组成
* 响应报文的组成
	* 协议版本
	* 状态码(表示成功或失败的数字)
	* 用以解释状态码的原因短句
	* 可选的响应首部字段
	* 实体主体

![响应报文构成](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.响应报文构成.png)

#### HTTP是不保存状态的协议
* HTTP是无状态协议.
* HTTP协议自身不对请求和响应之间的通信状态进行保存,即不对发送过的请求和响应状态做持久化处理.
* 每当有新的请求发送时,就有新的响应产生.
* 协议本身并不保留之前一切的请求或响应报文的信息.
* 优点:能快速处理大量的事务,确保协议的可伸缩性
* 缺点:无法处理某些业务,例如,同家网站跳转页面无法保持登录状态,需要重新登录.
* HTTP/1.1虽然是无状态协议,引入了Cookie技术实现期望的保持状态功能.

#### 请求URI定位资源
* HTTP协议使用URI定位互联网上的资源.
* 指定请求URI的方式
	* GET http://hackr.jp/index.htm HTTP/1.1
	* GET /index.htm HTTP/1.1  Host:http://hackr.jp
* 如果不是访问特定资源而是对服务器本身发起请求,可以用*来代替URI
	* GET * HTTP/1.1

#### 告知服务器意图的HTTP方法
* GET:获取资源

![GET](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.GET.png)

* POST:传输实体主体
	* 虽然用GET方法可以传输实体的主题,但一般不用GET方法进行传输,而是使用POST方法.
	* 虽然POST功能与GET很相似,POST的主要目的并不是获取响应的主体内容.

![POST](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.POST.png)

* PUT:传输文件
	* PUT方法用来传输文件,像FTP协议的文件上传一样
	* PUT方法自身不带验证机制,任何人都可以上传文件,存在安全问题,一般不使用该方法.
	* 配合Web应用程序的验证机制或者架构设计采用REST标准可能会开放使用PUT

![PUT](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.PUT.png)

* HEAD:获取报文首部
	* HEAD方法和GET方法一样,只是不放回报文主题部分.
	* 用于确认URI的有效性和资源更新的时间等

![HEAD](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HEAD.png)

* DELETE:删除文件
	* DELETE方法用来删除文件
	* 与PUT方法相反,同样不带验证机制

![DELETE](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.DELETE.png)

* OPTIONS:询问支持的方法
	* OPTIONS方法用来查询针对请求URI指定的资源支持的方法

![OPTIONS](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.OPTIONS.png)

* TRACE:追踪路径
	* TRACE方法是让Web服务器端将之前的请求通信返回给客户端的方法
	* 发送请求时,在Max-Forwards首部字段中填入数字,没经过一个服务端就将该数字减1,当数字刚好减少到0的时候,就停止传输,最后接收到服务的服务器端则放回状态码200OK的响应.
	* 客户端通过TRACE方法可以查询发出去的请求是怎么样被加工修改/篡改的.

![TRACE](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.TRACE.png)

* CONNECT:要求用隧道协议连接代理
	* CONNECT方法要求与代理服务器通信时建立隧道,实现用隧道协议进行TCP通信.
	* 主要使用SSL和TLS协议把通信内容加密后进过网络隧道传输
	* 格式:CONNECT 代理服务器名:端口号 HTTP/版本

![CONNECT](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.CONNECT.png)

#### 持久连接节省通信量
* HTTP协议初始版本,每进行一次HTTP通信就要断开一次TCP连接.
* 持久连接特点:只要任意一端没有明确提出断开连接,则保持TCP连接状态.
* 持戒连接的好处:减少了TCP连接的重复建立和断开所造成的额外开销,减轻了服务器端的负载.
* 除了服务端需要进行持久化,客户端也需要支持持久化连接.
* 持久化连接使得多数请求以管线化的方式发送成为可能.管线化技术出现后,不用等待响应就可以直接发送下一个请求.

#### 使用Cookie的状态管理
* Http是无状态协议,无法根据之前请求的状态进行本次的请求处理.
* 无状态协议优点:可减少服务器的CPU及内存资源的消耗,简化HTTP协议结构.
* Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态.
* Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息,通知客户端保存Cookie.当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入Cookie值后在发送出去.
* 服务器端发送客户端发送过来的Cookie后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息.

![Cookie流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.Cookie流程.png)

![Cookie报文变化](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.Cookie报文变化.png)

## HTTP信息

#### 用于HTTP协议交互的信息被称为HTTP报文
* 请求端(客户端)的HTTP报文叫做请求报文
* 响应端(服务器端)的叫做响应报文.
* HTTP报文本身是由多行数据构成的字符串文本.
* HTTP报文大致可分为报文首部和报文主体两块,并不一定要有报文主体

* 报文结构
	* 报文首部
		* 请求行:(客户端)包含用于请求的方法,请求URI和HTTP版本
		* 状态行:(服务端)包含表明响应结果的状态码,原因短语和HTTP版本
		* 首部字段:包含表示请求和响应的各种条件和属性的各类首部
	* 报文主体:报文的主要内容.(可选)
* 报文主体和报文首部之间通过空行(CR+LF)隔开
	* CR:回车符
	* LF:换行符

![HTTP报文结构](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTP报文结构.png)

![HTTP报文示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTP报文示例.png)

#### 编码提升传输速度
* HTTP在传输数据时可以按照数据原貌直接传输,也可以在传输过程中通过编码提供传输速率.
* 通过在传输时编码,能够有效的处理大量的访问请求.但是编码操作会消耗计算机的CPU资源.
* 常用编码
	* gzip
	* compress(UNIX系统的标准压缩)

#### 分割发送的分块传输编码
* 在HTTP通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求界面.
* 在传输大容量数据是,通常把数据分割成多块,能够让浏览器逐步显示页面.

#### 内容协商
* 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最为适合的资源.
* 内容协商会以语言/字符集/编码方式等位基准判断响应的资源.
* 内容协商三种类型
	* 服务器驱动协商
		* 由服务器进行内容协商,以请求的首部字段作为参考,在服务器端自动处理.以客户端发送的信息作为判定依据,并不一定能啥选出最优内容
	* 客户端驱动协商
		* 由客户端进行内容协商的方式,用户从浏览器显示饿可选项列表中手动选择.
	* 透明协商
		* 是服务器驱动和客户端驱动的结合体,是由服务器端和客户端给子进行内容协商的一种方法.

## 返回结果的HTTP状态码
* HTTP状态码负责表示客户端HTTP请求的返回结果和标记服务器端的处理是否正常以及不正常是通知出现的错误等工作.

#### 状态码告知从服务器端返回的请求结果
* 状态码的职责是当客户端想服务器发送请求时,描述返回的请求结果.
* 借助状态码,用户可以知道服务器端是正常处理了请求,还是出现了错误.
* 状态码有三位数字和原因短语组成.例如 200 OK

![状态码的类别](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.状态码的类别.png)

#### 2XX 成功
* 2XX的响应结果表明请求被正常处理了.
* 200 OK
	* 表示从客户端发来的请求在服务器端被正常处理了.
* 204 No Content
	* 表示服务器接收的请求已成功处理,但是返回的响应报文中不含实体的主体部分,也不允许返回任何实体的主体.
* 206 Partial Content
	* 表示客户端进行了范围请求,而服务器成功执行了这部分的GET请求.

#### 3XX 重定向
* 3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求.
* 301 Moved Permanently
	* 永久性重定向.
	* 表示请求的资源已被分配了新的URI,以后应使用资源现在所指的URI.
* 302 Found
	* 临时性重定向
	* 表示请求的资源已经被分配了新的URI,希望用户本次使用新的URI访问.
	* 与301不同的地方在于该资源不是永久性移动,而是临时性的.
* 303 See Other
	* 表示由于请求的资源存在着另一个URI,应使用GET方法定向获取请求的资源.
	* 303与302有这相同的功能,但是303状态码明确表示客户端当采用GET方法获取资源.
* 当301,302,303响应状态码返回时,几乎所有的浏览器都会把POST改成GET,并删除请求报文的主题,然后请求会自动再次重发.但是301,302标准是禁止POST方法改正GET的,但是大家都会这么做.
* 304 Not Modified
	* 表示客户端发送附带条件的请求时,服务器允许请求访问资源,但因为发生请求未满足条件的情况后,直接返回304 Not Midified.
	* 返回的报文不包含主体部分.
	* 304虽然被划分到了3XX,但是实际上和重定向没有任何关系.
* 307 Temporary Redirect
	* 临时重定向.
	* 该状态码与302有着相同的含义302,虽然302禁止把POST变化成GET,但是实际大家都会这么做.而307不会从POST变成GET.

#### 4XX客户端错误
* 4XX的响应结果表明客户端是发生错误的原因所在.
* 400 Bad Request
	* 表示请求报文中存在语法错误.
	* 当错误发生时,需修改请求的内容再次发送请求.
* 401 Unauthorized
	* 表示发送的请求需要有通过HTTP认证的信息.
	* 若之前已进行过1次请求,则表示用户认证失败.
* 403 Forbidden
	* 表明对请求资源的访问被服务器拒绝了
	* 服务器没有必要给出拒绝的详细理由,也可以在实体的主体部分对原因进行描述.
* 404 Not Found
	* 表明服务器上无法找到请求的资源

#### 5XX 服务器错误
* 5XX的响应结果表明服务器本身发生错误
* 500 Internal Server Error
	* 表明服务器在执行请求时发生了错误
* 503 Service Unavailable
	* 表明服务器暂时处于超负载或正在进行停机维护,现在无法处理请求

## 与HTTP协作的Web服务器
* 一台Web服务器可搭建多个独立域名的Web网站,也可作为通信路径上的中转服务提升传输效率.

#### 用单台虚拟主机实现多个域名
* HTTP/1.1允许一台HTTP服务器搭建多个Web站点.
* 在相同的IP地址下,由于虚拟主机可以寄存多个不同主机名和域名的web网站,因此在发送HTTP请求时,必须在host首部内完整指定主机名或域名的URI.

#### 通信数据转发程序:代理/网关/隧道
* HTTP通信时有一些用于通信数据转发的应用程序,例如代理/网关/隧道,可以配合服务器工作.
* 这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器,并且能接收从那台服务器发送的响应在转发给客户端.
* 代理
	* 代理是一种有转发功能的应用程序,扮演了服务器和客户端中间人的角色.
	* 接收客户端发送的请求并转发给服务器,同时也接收服务器返回的响应并转发给客户端.
	* 使用代理可以利用缓存技术减少网络带宽的流量,组织内部针对特定网站的访问控制,以获取访问日志为主要目的.
	* 代理有多重使用方法
		* 缓存代理
			* 预先将资源的副本(缓存)保存在代理服务器上,当代理再次接收到对相同资源的请求时,用缓存作为回应
		* 透明代理
			* 转发请求或响应时,不对报文做任何加工的代理类型
		* 不透明代理
			* 对报文做加工的代理类型
* 网关
	* 网关是转发其他服务器通信数据的服务器,接收从客户端发送来的请求时,就像自己拥有资源的源服务一样对请求进行处理.
	* 网关在通信线路上能够提供非HTTP的协议服务
	* 利用网关能提高通信的安全性
* 隧道
	* 隧道是在相隔甚远的客户端和服务器两者之间进行中转,并保持双方通信连接的应用程序
	* 隧道的目的确保客户端和服务器之间的安全通信
	* 隧道本身不解析HTTP请求
	* 隧道本身是透明的

#### 保存资源的缓存
* 缓存是指代理服务器或客户端本地磁盘内保存的资源副本.
* 利用缓存可减少对原服务器的访问,节省了通信的流量和通信的时间
* 缓存服务器是代理服务器的一种,并归类在缓存代理类型中.
	* 优势在于利用缓存可避免多次从原服务器转发资源
* 即便是有缓存,需要关注缓存的有效性问题
* 即使存在缓存,也会因为客户端的要求,缓存的有效期等因素,向源服务器确认资源的有效性.若缓存失效,再次获取新资源.
* 缓存不仅存在于缓存服务器内,还可以存在客户端浏览器内.
* 客户端浏览器缓存如果有效则直接读取,不想服务器请求资源.

## HTTP首部
* HTTP协议的请求和响应报文中必须包含HTTP首部.
* 首部内容为客户端和服务器分别处理请求和响应提供所需信息.

#### HTTP请求报文

![http请求报文格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.http请求报文格式.png)

#### HTTP响应报文

![http响应报文格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.http响应报文格式.png)

#### HTTP首部字段
* 格式
	* 首部字段名:字段值1,字段值2
* 首部字段根据实际用途被分为4种类型
	* 通用首部字段
	* 请求首部字段
	* 响应首部字段
	* 实体首部字段

#### 通用首部字段

* 请求报文和响应报文都会使用的首部字段

![通用首部字段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.通用首部字段.png)

#### 请求首部字段

* 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息.

![请求首部字段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.请求首部字段.png)

#### 响应首部字段

* 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

![响应首部字段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.响应首部字段.png)

#### 实体首部字段

* 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

![实体首部字段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.实体首部字段.png)

## 确保Web安全的HTTPS
* 在HTTP协议中有可能存在信息窃听或身份伪装等安全问题.
* 使用HTTPS通信机制可以有效防止安全问题

#### HTTP的缺点
* 通信使用明文(不加密),内容可能被窃听
* 不验证通信方的身份,有可能遭遇伪装
* 无法证明报文的完整性,有可能已遭篡改

#### 加密处理防止被窃听
* HTTP协议本身不具备加密的功能,所以使用明文发送
* TCP/IP工作机制,通信内容在所有的通信线路上都可能遭到窥视
* 通信的加密
	* HTTP协议没有加密机制,可以通过和SSL(安全套接层)和TLS(安全传输协议)的组合使用,加密HTTP的通信内容.
	* 用SSL建立安全通信线路之后,就可以在线路上进行HTTP通信了.
	* 与SSL组合使用的HTTP被称为HTTPS(超文本安全传输协议)
* 内容加密
	* 对HTTP报文所含的内容进行加密处理.
	* 为了做到有效的内容加密,前提是要求客户端和服务器同时具备加密和解密机制
	* 不同于SSL+TLS将整个通信线路进行加密,还存在被篡改的风险

#### 不验证通信方的身份就可能遭遇伪装
* HTTP协议中的请求和响应不会对通信方进行确认
	* 任何人都可以发起请求
	* 服务器只要接受到请求,不管对方是谁都会返回一个响应
* 任何人都可发起请求机制存在的隐患
	* 伪装服务器:无法确定请求发送至目标的服务器是否按真实的意图返回响应的那台服务器的响应.
	* 伪装客户端:无法确定响应返回到的客户端是否按真实意图接收响应的那个客户端.
	* 无法确定正在通信的对方是否具备访问权限.
	* 无法判定请求源自于哪个客户端
	* 无意义的请求也会照单全收
* 查明对手的证书
	* HTTP协议无法确定通信方,但是SSL可以
	* SSL不仅提供加密处理,还使用了一种被称为证书的手段用来确定通信方.
	* 证书由值得信任的第三方机构颁发,用以证明服务器和客户端是实际存在的.
	* 伪造证书从技术角度来说是异常困难的一件事
	* 只要通信方(客户端/服务器)持有证书,可判断其真实意图

#### 无法证明报文完整性,可能已遭篡改
* HTTP协议无法证明通信报文的完整性
* 验证完整性的常用办法
	* MD5/SHA-1等散列值校验的方法
	* 数字签名方法
* 但是需要客户端自己检验文件是否完整,浏览器无法自动帮助检验

#### HTTPS = HTTP + 加密 + 认证 + 完整性保护
* HTTPS不是应用层的一种新协议,只是HTTP通信接口部分用SSL和TLS协议代替而已.
* 通常HTTP直接和TCP通信.HTTPS则是先跟SSL通信然后再和TCP通信.
* 采用了SSL后,HTTP就拥有了加密/认证/完整性保护的功能.
* SSL是独立于HTTP协议的,应用层的其他协议也可以使用SSL来达到网络安全.

![HTTPS结构](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTPS结构.png)

#### 公开密钥加密方式解决了共享密钥加密的传输密钥的问题
* 共享密钥加密(对称密钥加密)
	* 加密算法是公开的,密钥是保密的.
	* 加密和解密都会用到密钥,没有密钥就无法对密钥解密,只要有密钥就能够解密,妥善保管密钥.
	* 面临问题:用密钥加密后的数据发送给对方,对方需要密钥才能够完成解密.如何安全的发送密钥给对方呢?如果密钥能安全到达,数据也能够安全到达.如果密钥被窃取,数据也被窃取.
* 公开密钥加密方式很好的解决了共享密钥加密的困难.
	* 公开加密密钥使用了一对非对称的密钥
		* 一把私有密钥,不能让其他人知道
		* 一把公开密钥,可以任意发布
	* 使用对方的公开密钥加密报文
	* 收到加密报文后使用自己的私钥进行解密
	* 不需要发送用来解密的密钥
	* 不用密钥就破解公钥报文很困难,不太现实.

#### HTTPS采用混合加密机制
* 共享密钥加密方式,如果密钥能够安全传输,就不会考虑对数据加密
* 公开密钥加密方式,处理速度较慢.
* HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制.
* 混合机制充分利用了两者各自的优势
	* 在交换密钥环节使用公开密钥加密方式
	* 之后建立的通信交换报文阶段则使用共享密钥加密方式
	* 若在同时时就使用公开密钥加密方式,效率就很低.

![混合加密机制](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.混合加密机制.png)

#### 证明公开密钥正确性的证书
* 混合加密机制的问题是无法证明公开密钥本身就是货真价实(目标服务器)的公开密钥,很可能中途被替换掉.
* 使用数字证书认证机构和其机关办法的公开密钥证书来证明公开密钥的所属.
* 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上.
* 数字认证机构的业务流程
	1. 服务器的运营人员像数字证书认证机构提出公开的申请
	2. 数字证书认证机构判明提出申请者的身份
	3. 数字证书认证机构对该申请的公开密钥做数字签名
	4. 数字证书认证机构分配已经签名的公开密钥
	5. 绑定公开密钥和数字证书
* 服务器收到认证机构颁发的公钥证书后发送给客户端,以进行公开密钥的加密通信.
* 客户端收到服务器发来的公钥证书后,对证书上的数字进行验证.一般客户端的浏览器内部会事前植入认证机构,通过和认证机构的比对来验证证书的有效性.一旦通过即可通信.

![数字证书颁发流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.数字证书颁发流程.png)

#### HTTPS的安全通信流程

![HTTPS的安全通信流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTPS的安全通信流程.png)

#### HTTPS当使用SSL时处理速度会变慢
* SSL 的慢分两种。
	* 一种是指通信慢,和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。
	* 另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。* 另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。
* 因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。针对速度变慢这一问题，并没有根本性的解决方案.

#### 同时使用HTTP和HTTPS

* HTTPS与纯文本通信HTTP相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。* 如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用HTTPS 加密通信。* 特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。

## 访问用户的身份认证

#### 用户的核对信息
* 密码:本人才会知道的字符串信息
* 动态令牌:本人设备内显示的一次性密码
* 数字证书:本人终端持有的身份认证
* 生物认证:指纹和虹膜等生理信息

#### HTTP使用的认证方式
* BASIC认证(基本认证)
* DIGEST认证(摘要认证)
* SSL客户端认证
* FormBase认证(基于表单认证)

#### BASIC认证
* BASIC认证(基本认证)是从 HTTP/1.0 就定义的认证方式,是Web服务器与通信客户端之间进行的认证方式.
* 认证步骤
	1. 当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式(BASIC)及 Request-URI 安全域字符串(realm).
	2. 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的转换工作。
	3. 接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI资源的响应。

![BASIC认证](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.BASIC认证.png)

* BASIC认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。* BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。

#### DIGEST认证
* 从 HTTP/1.1 起就有了 DIGEST 认证。 
* DIGEST认证同样使用了同BASIC质询/响应的方式.但不会像 BASIC 认证那样直接发送明文密码.

![DIGEST认证](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.DIGEST认证.png)

* DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。* DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也有所受限。

#### SSL客户端认证
* 从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。
* SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。
* 步骤
	0. 为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。
	1. 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。
	2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。
	3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信. 
* 使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。
* 在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。
 
#### 基于表单认证
* 基于表单的认证方法并不是在 HTTP 协议中定义的。
* 客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。
* 基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session（会话）。* 基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。* 但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来.无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。

* 步骤
	1.客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。	2. 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。
	3. 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。

![session管理及Cookie状态管理](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.session管理及Cookie状态管理.png)

#### 认证多半为基于表单认证
* HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证因为安全等级问题不怎么使用。
* SSL 客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。
* 只好使用由 Web 应用程序各自实现基于表单的认证方式。

## 基于HTTP的功能追加协议
* 在建立 HTTP 标准规范时，制订者主要想把 HTTP 当作传输 HTML 文档的协议.
* 虽然 HTTP 协议既简单又简捷，但随着时代的发展，其功能使用上捉襟见肘的疲态已经凸显。

#### HTTP瓶颈
* 一条连接上只可发送一个请求
* 请求只能从客户端开始。客户端不可以接收除响应以外的指令。* 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。* 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。* 可任意选择数据压缩格式。非强制压缩发送。
* 服务器每次请求都会发送全部的数据给客户端.
* 无法预知服务器端更新.使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。

![HTTP通信模式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTP通信模式.png)

#### AJAX局部更新

![AJAX局部更新](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.AJAX局部更新.png)

* Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。
* 利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生.Ajax 仍未解决 HTTP 协议本身存在的问题。

#### Comet延迟应答

![Comet](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.Comet.png)

* 一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。* 通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。* 内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决 HTTP 协议本身存在的问题。

#### 增加SPDY会话层
* SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。* SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。

![SPDY会话层](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.SPDY会话层.png)

* SPDY的功能
	* 多路复用流
		* 通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。
	* 赋予请求优先级
		* SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
	* 压缩 HTTP 首部
		* 压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。
	* 推送功能
		* 支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
	* 服务器提示功能
		* 服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

* SPDY基本上只是将单个域名（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制.
* SPDY是一种可有效消除 HTTP 瓶颈的技术.

#### WebSocket全双工通信
* 利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。
* WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。
* 一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。
* 特点
	* 推送功能:支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
	* 减少通信量:只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。

* 为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”的步骤。因为建立websocket连接前还是http协议,所以websocket握手必须要客户端先发起.

![websocket握手](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.websocket握手.png)

* 成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。

![websocket通信](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.websocket通信.png)

#### HTTP2.0
* HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验.