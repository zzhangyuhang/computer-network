# 图解HTTP
## 了解Web和网络基础
#### Web是建立在Http协议上通信的
* Http是超文本传输协议,协议指规则的约定
* Web使用Http的协议作为规范,完成从客户端到服务器等一系列运作流程.
* 客户端通过指定的访问地址url获取/上传服务器资源.
* 服务器通过使用Http协议与客户端完成资源通信.
* Web的构建采用的是www(万维网)构建技术,包括3部分
	* 超文本标记语言HTML
	* 超文本传输协议HTTP
	* 指定文本所在地址URL

#### HTTP是TCP/IP协议族内部的一个子集
* TCP/IP协议族按层次分别为以下4层
	* 应用层:FTP/DNS/HTTP
	* 传输层:TCP/UDP
	* 网络层:IP
	* 数据链路层

![TCP/IP通信流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.通信流程.png)

#### 与HTTP关系亲密的协议:IP TCP DNS

* IP指的是IP协议族,作用是把各种数据包传送给对方,其中两个重要条件
	* IP地址,可变化
	* MAC地址,基本不会改变
	* 两个地址需要进行配对,才能完成在IP协议上的传输
	* IP间的通信需要依赖MAC地址.采用ARP协议,能完成IP地址解析工作,把知道的目标地址的IP地址解析成为MAC地址,然后完成传输.

![ARP地址解析](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.ARP地址解析.png)

* TCP位于传输层,提供可靠的字节流服务.
	* TCP协议采用三次握手策略,一定会向对方确认是否成功传达
	* 握手过程中使用了TCP的标志:SYN(synchronize)和ACK(acknowledgement)
		* 发送端首先发送一个带SYN标志的数据包给对方
		* 接收端收到后,会传一个带有SYN/ACK标志的数据包以示传达确认信息
		* 发送端再回传一个带ACK标志的数据包,代表握手结束 
	* 若握手过程中莫名中断,TCP协议会再次以相同的顺序发送相同的数据包
	* 除了三次握手,TCP协议还有其他手段保证通信的可靠性

![三次握手](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.三次握手.png)

* DNS提供域名到IP地址之间的解析服务,和HTTP一样位于应用层.
	* 用户经常使用主机名/域名来访问对方计算机,而不是直接由IP地址来访问.
	* DNS协议通过提供的域名查找IP地址,或逆向从IP地址反查域名的服务

![DNS域名解析](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.DNS域名解析.png)

#### HTTP协议通信过程
0. 客户端获取到服务器的域名
1. 通过DNS协议获取到目标域名的IP地址
2. 通过HTTP协议生成目标服务器的请求报文,报文地址是DNS的解析IP地址
3. TCP将HTTP报文分割成多个TCP报文段根据IP地址可靠的传递给服务器
4. IP对TCP报文包进行封装成IP包,通过ARP协议解析出MAC地址进行传输
5. 路由器完成链路选择将IP包准确的传递到目标服务器
6. 服务器收到IP包上交给TCP协议
7. TCP协议将IP包拆解成TCP报文,以原来报文的顺序排序重组
8. TCP协议将恢复的报文上交给HTTP协议进行请求处理
9. 同样运用上述的过程完成请求资源的回传

![HTTP协议通信过程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HTTP协议通信过程.png)

#### URI是同一的资源描述符,而URL则是URI的子集
* URI是统一资源描述符
	* 规定统一的格式,可方便处理多种不同类型的资源,而不用根据上下文环境来表示资源指定的访问方式
	* 可标识任何东西,不仅是文档文件/图像/服务,也可以是多数的集合体
* URL表示资源的地点,URL是URI的子集.
* 绝对URI格式由7部分构成
	* 协议方案名:不区分大小写,最后必须要附上一个冒号.例如:https:/http:/data:/js:
	* 登录信息(认证)
	* 服务器地址:可以以是DNS可解析的域名,也可以是IPv4/IPv6的IP地址
	* 服务器端口号
	* 带层次的文件路径
	* 查询字符串:?后的查询条件,针对文件路径内的资源,可传入任意数量条件.(可选)
	* 片段标识符(可选)

![绝对URI格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.绝对URI格式.png)

* RFC:指定HTTP协议技术的标准文档.应用程序会按照RFC确定的标准实现.如果应用服务器没有遵照RFC的标准实现,很可能并无法访问.

## 简单的HTTP协议

#### HTTP协议用于客户端和服务器端之间的通信
* 请求访问文本或图像等资源的一端称为客户端
* 提供资源响应的一端称为服务器端
* 一条通信线路上必定有一段是客户端,另一端则是服务器端.两段角色可能互换.
* HTTP能够区分两端的身份
* 请求必定由客户端发出,而服务器端回复响应.肯定先从客户端开始建立通信,服务器端没有收到请求之前是不会发送响应的.

#### 请求报文的组成
* 请求报文的组成
	* 请求方法:GET/POST
	* 请求URI
	* 协议版本
	* 可选的请求首部字段
	* 内容实体

![请求报文构成](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.请求报文构成.png)

#### 响应报文的组成
* 响应报文的组成
	* 协议版本
	* 状态码(表示成功或失败的数字)
	* 用以解释状态码的原因短句
	* 可选的响应首部字段
	* 实体主体

![响应报文构成](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.响应报文构成.png)

#### HTTP是不保存状态的协议
* HTTP是无状态协议.
* HTTP协议自身不对请求和响应之间的通信状态进行保存,即不对发送过的请求和响应状态做持久化处理.
* 每当有新的请求发送时,就有新的响应产生.
* 协议本身并不保留之前一切的请求或响应报文的信息.
* 优点:能快速处理大量的事务,确保协议的可伸缩性
* 缺点:无法处理某些业务,例如,同家网站跳转页面无法保持登录状态,需要重新登录.
* HTTP/1.1虽然是无状态协议,引入了Cookie技术实现期望的保持状态功能.

#### 请求URI定位资源
* HTTP协议使用URI定位互联网上的资源.
* 指定请求URI的方式
	* GET http://hackr.jp/index.htm HTTP/1.1
	* GET /index.htm HTTP/1.1  Host:http://hackr.jp
* 如果不是访问特定资源而是对服务器本身发起请求,可以用*来代替URI
	* GET * HTTP/1.1

#### 告知服务器意图的HTTP方法
* GET:获取资源

![GET](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.GET.png)

* POST:传输实体主体
	* 虽然用GET方法可以传输实体的主题,但一般不用GET方法进行传输,而是使用POST方法.
	* 虽然POST功能与GET很相似,POST的主要目的并不是获取响应的主体内容.

![POST](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.POST.png)

* PUT:传输文件
	* PUT方法用来传输文件,像FTP协议的文件上传一样
	* PUT方法自身不带验证机制,任何人都可以上传文件,存在安全问题,一般不使用该方法.
	* 配合Web应用程序的验证机制或者架构设计采用REST标准可能会开放使用PUT

![PUT](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.PUT.png)

* HEAD:获取报文首部
	* HEAD方法和GET方法一样,只是不放回报文主题部分.
	* 用于确认URI的有效性和资源更新的时间等

![HEAD](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.HEAD.png)

* DELETE:删除文件
	* DELETE方法用来删除文件
	* 与PUT方法相反,同样不带验证机制

![DELETE](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.DELETE.png)

* OPTIONS:询问支持的方法
	* OPTIONS方法用来查询针对请求URI指定的资源支持的方法

![OPTIONS](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.OPTIONS.png)

* TRACE:追踪路径
	* TRACE方法是让Web服务器端将之前的请求通信返回给客户端的方法
	* 发送请求时,在Max-Forwards首部字段中填入数字,没经过一个服务端就将该数字减1,当数字刚好减少到0的时候,就停止传输,最后接收到服务的服务器端则放回状态码200OK的响应.
	* 客户端通过TRACE方法可以查询发出去的请求是怎么样被加工修改/篡改的.

![TRACE](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.TRACE.png)

* CONNECT:要求用隧道协议连接代理
	* CONNECT方法要求与代理服务器通信时建立隧道,实现用隧道协议进行TCP通信.
	* 主要使用SSL和TLS协议把通信内容加密后进过网络隧道传输
	* 格式:CONNECT 代理服务器名:端口号 HTTP/版本

![CONNECT](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.CONNECT.png)

#### 持久连接节省通信量
* HTTP协议初始版本,每进行一次HTTP通信就要断开一次TCP连接.
* 持久连接特点:只要任意一端没有明确提出断开连接,则保持TCP连接状态.
* 持戒连接的好处:减少了TCP连接的重复建立和断开所造成的额外开销,减轻了服务器端的负载.
* 除了服务端需要进行持久化,客户端也需要支持持久化连接.
* 持久化连接使得多数请求以管线化的方式发送成为可能.管线化技术出现后,不用等待响应就可以直接发送下一个请求.

#### 使用Cookie的状态管理
* Http是无状态协议,无法根据之前请求的状态进行本次的请求处理.
* 无状态协议优点:可减少服务器的CPU及内存资源的消耗,简化HTTP协议结构.
* Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态.
* Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息,通知客户端保存Cookie.当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入Cookie值后在发送出去.
* 服务器端发送客户端发送过来的Cookie后,会去检查究竟是从哪一个客户端发来的连接请求,然后对比服务器上的记录,最后得到之前的状态信息.

![Cookie流程](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.Cookie流程.png)

![Cookie报文变化](https://github.com/zzhangyuhang/computer-network/blob/master/photo/0.Cookie报文变化.png)