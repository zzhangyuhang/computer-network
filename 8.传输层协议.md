# 传输层协议

## 传输层与网络层服务的区别
* 网络层
	* IP协议提供了在主机之间传送包的服务,不保证任何服务质量
	* 包目的地是主机,没有对接受包的用户或应用程序进行成细致标识
* 传输层
	* 能够识别主机上的多个目的地址
	* 允许多个应用程序独立的进行数据报文的收发

![整体协议集](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.整体协议集.png)

上图是互联网的整体协议集.

## 传输层协议
* 因特网的传输层向应用层提供了两种服务:无连接的不可靠数据传输和面向连接的可靠的数据传输,将IP协议提供的主机-主机之间包传递服务扩展到端-端进程之间数据传输.
* 传输层协议主要分为TCP/UDP两种传输协议.

![传输层协议分类](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.传输层协议分类.png)

上面是传输层的协议分类,TCP主要是提供面向连接的可靠的服务.UDP则提供的是无连接的不可靠的服务.传输层无论服务可靠与否都是建立在网络层的无可靠的IP协议之上的.

* UDP
	* 将底层IP协议从客户机传递到服务器的数据交付到特定应用进程	* 将校验有错的数据报文丢弃但不采取任何弥补措施
	* 基本功能
		* 进程-进程数据传输
		* 差错检验,但是不纠错
	* 主要应用:电影音乐等流媒体应用

![UDP示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP示例.png)

* TCP
	* 将底层IP协议从客户机传递到服务器的数据交付到特定应用进程
	* 将校验有错的数据报文丢失,并采取相应的差错控制措施
	* 当网络出现拥塞时要及时发现并采取相应的拥塞控制措施
	* 基本功能
		* 进程-进程数据传输
		* 差错检验
		* 可靠数据传递
		* 面向连接
		* 拥塞控制
	* 主要应用:文件传输应用

![TCP示例](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP示例.png)

### UDP
#### 报文格式

![UDP报文格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP报文格式.png)

* UDP报文的封装

![UDP报文封装](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP报文封装.png)

UDP报文中包含要传递的进程(端口号指明),UDP报文被封装在IP包中.IP包指向因特网的某台主机逻辑地址(IP地址指明).IP包被封装在链路层的帧中指向某台主机的物理地址(MAC地址指明).

#### 差错检验
* UDP提供了不可靠的无连接传输服务.它使用IP提供的服务传输报文,但增加了对给定主机上多个目标进行区别的能力.
* UDP报文可能出现丢失/重复和乱序等错误现象
* 使用UDP的应用程序需要时自行弥补UDP的不足
* 协议特点
	* 没有确认机制
	* 不对报文排序
	* 没有超时机制
	* 没有控制流量

![UDP不可靠数据通道](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP不可靠数据通道.png)

上图是UDP的不可靠通信.UDP在传输数据的时候可能会发生丢失/损坏/重复/乱序等错误.使用UDP协议进行传输的时候需要应用层补足纠错能力.

* UDP只有差错检验机制,不对传输错误做任何处理
* UDP接收端对收到报文计算校验和
* 如果校验和建设有错则丢弃报文

![UDP进行数据校验](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP进行数据校验.png)

上图是UDP进行数据校验,IP包中在接收的时候也会进行校验,但是校验则知识对IP包头内容进行校验,并没有涉及到IP的数据有效载荷部分.UDP的校验则对所有内容进行校验,提供了唯一对数据是否传送到目的地的监督.

* UDP校验和特性
	* 校验和的范围覆盖了报文头和有效载荷
	* 如果报文长度是技术用0填成偶数字节
	* 校验和为0表示发送端没有计算校验和
	* 当计算出校验和为0则用全1表示

![UDP校验和计算方法](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP校验和计算方法.png)

上面是UDP校验和计算方法,注意在UDP报文传输中没有出现错误时,接收端计算的校验和应该为全1.

* UDP伪头:仅存在于计算校验和时贴在UDP报文的前缀,不属于被传输的UDP报文.
	* 源IP地址 目标IP地址
	* IP包的协议字段
	* UDP报文长度

![UDP伪头](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP伪头.png)

上面UDP伪头的示例,在传输的时候是没有UDP伪头的,只有在计算校验和的时候才会加上.但是UDP报文长度是不包含伪头的.可以理解为在计算校验和的时候伪头起到了辅助计算的作用,但是伪头不是真正属于UDP报文.

* 伪头的设置使得UDP两次检查应用数据是否到达正确的目的地
* 长度在校验和计算中出现两次,且UDP报文长度不包含伪头
* 校验和计算完毕,传输UDP报文时要去掉伪头

#### 多路复用分用和端口
* 因特网的传输层通过端口号实现应用进程的多路复用和多路分用.
* UDP多路复用和分用
	* 接收多个上层应用程序送来的数据,把数据封装成UDP数据报,下传给网络层IP协议实体传输
	* 接收下层IP协议实体送来的UDP数据报,取出包含的数据送出上层对应的应用程序

![UDP多路复用和分用](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.UDP多路复用和分用.png)

* UDP端口的管理
	* TCP/IP采纳了一种混合方式对端口地址进行管理
		* 对某些知名端口进行统一分配(0-1023)
		* 为应用程序留下了一个很大的端口取值范围
	* 管理的集中性
		* 一个管理机构负责对端口的集中分配和发布
		* 所有软件在设计时都要遵守分配规定
	* 绑定的动态性
		* 应用程序需要时由网络软件指定一个端口,即程序与端口号在生存期间动态绑定
* 为什么选择UDP?
	* 无需管理连接
		* 无需建立连接和维护连接状态
		* 没有连接省却了维护收发缓冲区,拥塞控制参数/序号和确认好等状态信息
		* 相比TCP可支持更多的客户端
	* 报头开销小
		* TCP报文头20字节长
		* UDP报文头8字节长
	* 应用程序可控制性
		* 应用进程可控制何时发送数据
		* TCP的拥塞控制机制阻止TCP的立即发送
		* TCP只能收到确认后才能发送后边的数据
		* 对于流媒体传输需要满足最小的发送速率请求
* UDP的使用场合
	* 流媒体应用(网咯电话\视频会议)可容忍少量的报文丢失,在有拥塞控制的TCP上工作很糟糕
	* 域名系统随时为客户提供名字到IP地址的映射查询服务

#### UDP协议应用-域名系统
* 域名:用来表示主机\电子邮箱\服务器等便于记忆的名字,该名字特定于某个域,具有因特网全局唯一性.
* 域名系统(DNS):将主句名/电子邮件地址/web服务器名等映射成IP地址的分布式数据库系统.
* DNS特点
	* 层次的
	* 分布式的
	* 基于自治域
* 域名具有层次结构

![DNS域名的层次机构](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS域名的层次机构.png)

上图示DNS域名的层次空间,分为顶级域名-四级域名.越高等级的域名在DNS域名的最后.例如yanwei.net.pku.edu.cn,顶级域名为cn,二级域名为edu,三级域名为pku,四级域名为yanwei.net.

* 根服务器:它的管理区域是组成整棵树的服务器,这些服务器是得到授权的服务器.
	* 授权服务器
		* 域是一个行政管理空间
		* 每个域有个负责该域名空间名字授权中心
		* 域管理员负责域名空间的命名
		* 域名解析授权可由父传给子节点

![DNS域名的层次管理](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS域名的层次管理.png)

DNS域名是层次管理的,本级域名由上一级域名授予和管理.

* 域名解析:给定一个域名解析出其对应的IP地址的过程
* 资源记录:给出了名字和IP地址的绑定活映射关系,是一个5元组.
	* 名字(Name)
	* 值(value)
	* 类型(type)
	* 分类(class)
	* 生存期(TTL)
* DNS服务器维护一张资源记录表,响应针对本域名子的解析请求

![DNS域名的解析](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS域名的解析.png)

DNS域名的解析是通过DNS服务器里的资源记录表进行解析的,资源记录表记录了本域名名字的解析IP地址.DNS解析也是层次解析.

* DNS主要功能
	* 提供名字和地址的映射关系
	* 指向子域的DNS服务器
	* 提供各类主机别名
		* 例如:邮件服务器别名
		* 别名一般比规范名更易于记忆
		* DNS可返回对应的规范名和IP地址
	* 提供负载均很
		* 例如:www.sina.com.cn对应多个具有不同的IP地址的服务器
		* DNS数据库包括所有的IP地址
		* 每次DNS查询将获得该组IP地址单次序是循环的
	* 提供缓存
		* DNS服务器在向请求方返回查询结果时,将查询结果存储在内部的告诉缓存中.后续客户返回同样请求,则直接返回缓存结果,但是需要声明这个查询结果是来自高速缓存的.即解析结果是非授权的.
		* 非授权信息(Non-authoritative):高速缓存内的信息,曾经受到过的查询信息.

* DNS查询方式
	* 递归查询
	* 迭代查询

 ![DNS递归查询](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS递归查询.png)
 
 ![DNS迭代查询](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS迭代查询.png)
 
* DNS报文

 ![DNS报文头](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS报文头.png)
 
上图是DNS报文头的格式.
 
  ![DNS报文正文](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS报文正文.png)
  
上图是DNS报文正文.报文正文内容是可变长的,不是固定不变的.
  
   ![DNS报文传递](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.DNS报文传递.png)
   
 DNS报文传递方式并不是一成不变的用UDP进行传递.当报文问响应报文的时候且报文长度大于512字节则采用TCP协议进行传输.

### TCP
#### TCP和UDP基本功能的不同

![TCP和UDP基本功能的不同](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP和UDP基本功能的不同.png)

TCP除了支持UDP支持的进程间传输和差错检验外,还支持可靠的数据传输,以及对连接的管理和拥塞的控制.

* TCP多路复用和差错检验方法和UDP相同
* TCP利用肯定确认机制对差错实行控制
* TCP的连接建立和释放均采用了"三次握手"
* TCP对网络拥塞进行了端-端的控制

#### TCP协议特性
* 因特网的传输控制协议TCP向上面的应用层提供了面向连接的可靠的端-端字节流传输服务.
* TCP协议特性
	* 连接性
		* 面向连接
			* 两个端系统维护连接状态
			* 不同于时分活频分复用
			* 不同于虚电路
		* 全双工
			* 连接是全双工的,同时双向数据传送数据
		* 点-点传输
			* 连接是点-点的,只能一对一通信(不支持一对多组播通信)
		* 客户端和服务器要建立一条逻辑通道
		* 客户机和服务器可同时向对方发送报文
		* 客户机只能和一个服务器连接并通信
	* 缓存并无边界发送
		* 有缓冲的发送
			* 应用进程交给TCP发送的数据可能需要缓冲以便和后续数据一并传输
		* 无结构数据流
			* 用TCP传输数据时不保证数据便捷,只是以字节流的形式发送
		* 应用进程通过socket发出的数据被缓存在缓冲区
		* 缓存数据何时从本地发出取决与具体TCP实现
		* 端-端之间不保留报文边界

![TCP特性](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP特性.png)

上图是TCP特性示例,TCP的连接是端-端的,之间建立起一条全双工的逻辑通道,双方都可以同时收发消息给对方.同时发送的消息可以被缓存在本地并选择性发送以及示意字节流的形式发送的.

#### TCP报文格式

![TCP报文格式](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP报文格式.png)

TCP报文中还拥有一部分标志位,用来控制连接行为.

![TCP报文标志位](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP报文标志位.png)

* TCP段:TCP实体交换的协议数据报文
	* TCP的段独立确认
	* IP的分段不能独立确认
	* IP的分段不能独立重传
* 最大段长(MSS):TCP段允许的最大长度
* 最大段的选择
	* MSS太小降低网络利用率
	* MSS太大降低网络性能
	* 连接两端位于同一物理网络可选择MSS与MTU适应
	* 连接两端位于不同物理网络最好设置为途径网络最小MTU
	* MSS的最终确定需要连接两端协商

* TCP包的封装

![TCP包封装](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP包封装.png)

上图是TCP包的封装,封装在IP包中进行传输.


#### 接收数据和累计确认
* TCP接收数据特性
	* 发送端为每个字节编号
	* 采用累积确认
	* 确认号为接收端等待接收的下一个字节序号
	* 接收端缓存到达的乱序数据

![TCP累积接收数据](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP累积接收数据.png)

#### 紧急数据的发送和接收
* 带外数据:不属于正常数据流并且通常具有控制功能的信息.发送端将带外数据标为紧急.
* 通过控制标志位来完成紧急数据的收发
	* URG标志位强迫TCP发送当前数据流中的所有字节
	* URG指针指出数据流中紧急数据所在
	* PSH标志位要求接受端立即执行紧急操作
	* 接收端收到紧急数据后通知响应应用程序
	* 当应用程序希望立即发送紧急数据并且另一端立即处理紧急数据时,可组合使用URG和PSH标志位以及URG指针.

![TCP紧急数据标志位](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP紧急数据标志位.png)

#### 多路复用分用
* TCP多路复用和分用
	* 接收多个上层应用程序数据,把数据封装成TCP段,下传给网络层IP协议实体传输
	* 接收下层IP协议实体送来的TCP段,取出包含的数据送给上层对应的应用程序
* 因特网的传输层通过端口号实现应用进程的多路复用和多路分用

![TCP多路复用和分用](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP多路复用和分用.png)

* 一些知名的TCP端口

![TCP知名端口](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP知名端口.png)

#### 差错检验
* 发送端对发送的TCP端计算校验和
* 接收端对收到的TCP端计算校验和
* 如果校验和检测有错则丢弃出错段
* TCP校验和特性
	* 校验和的范围覆盖了报文头和有效载荷
	* 如果报文长度是奇数用0填成偶数字节
	* 校验和为0表示发送端没有计算校验和
	* 当计算出校验和为0则全1表示
* IP协议没有对IP包中数据部分计算校验和
* TCP有完善的差错控制机制,通过校验和校验数据是否正确传送到目的地,丢失出错端,发送端重传
* TCP伪头:仅存在于计算校验和时贴在TCP报文的前缀,不属于被传输的TCP段.
	* 源IP地址/目标IP地址
	* IP包的协议字段
	* TCP段的总长度
* 计算校验和纳入伪头使得TCP两次检查应用程序是否到达正确目的地
* TCP段的长度在校验和计算中出现两次,TCP段长不包括伪头
* 校验和计算完毕,传输TCP报文时要去掉伪头

![TCP伪头](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP伪头.png)

伪头不参与运输仅参与计算校验和.

#### 连接管理
* TCP连接建立
	* 被动打开与主动打开
	* TCP连接建立采用"三次握手"方法
	* TCP采用基于始终的序号善生方案
	* 双方协商本次连接的初始序号

![TCP建立连接](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP建立连接.png)

* TCP连接释放
	* TCP协议用改进的"三次握手"来关闭连接
	* 每个方向连接单独释放,超时值设定为2倍的MSL

![TCP连接释放](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP连接释放.png)

#### 可靠数据传输
* TCP采用动态大小活动窗口控制发送
* 发送窗口内序号是可连续发送的字节
* 发出段中的序号指数据在字节流中的编号
* 返回段中确认号指接收端等待接收的字节编号

![TCP数据帧发送](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP数据帧发送.png)

TCP的数据帧发送采用的是动态活动窗口的形式.发送窗口是可以变化的,受流量控制.发送串口中的数据帧序号是连续的字节起始位置.

TCP按照以下特定顺序工作：

1. 放置于重传队列中，计时器开始 包含数据的片段一经发送，片段的一份复制就放在名为重传队列的数据结构中，此时启动重传计时器。因此，在某些时间点，每一个片段都会放在队列里。队列按照重传计时器的剩余时间来排列，因此TCP软件可追踪那几个计时器在最短时间内超时。

2. 确认处理 如果在计时器超时之前收到了确认信息，则该片段从重传队列中移除。

3. 重传超时 如果在计时器超时之前没有收到确认信息，则发生重传超时，片段自动重传。当然，相比于原片段，对于重传片段并没有更多的保障机制。因此，重传之后该片段还是保留在重传队列里。重传计时器被重启，重新开始倒计时。如果重传之后没有收到确认，则片段会再次重传并重复这一过程。在某些情况下重传也会失败。我们不想要TCP永远重传下去，因此TCP只会重传一定数量的次数，并判断出现故障终止连接。

* 累计确认:只要某段的确认在该段超时之前到达发送端,因累计确认含义,发送端就能肯定该段已经被正确接收无需重发.
	* 优点
		* 后续确认段包含了之前传输正确的隐含信息
		* 确认段丢失不一定导致发送端的重发
	* 缺点
		* 发送端不能收到所有成功发送段的确认信息
		* 只知道已收到的数据流中的某个一位置信息
		* 缺乏全部成功传送的信息->累计确认的效率低下

* TCP数据包中的序列号（Sequence Number）不是以报文段来进行编号的，而是将连接生存周期内传输的所有数据当作一个字节流，序列号就是整个字节流中每个字节的编号。一个TCP数据包中包含多个字节流的数据（即数据段），而且每个TCP数据包中的数据大小不一定相同。在建立TCP连接的三次握手过程中，通信双方各自已确定了初始的序号x和y，TCP每次传送的报文段中的序号字段值表示所要传送本报文中的第一个字节的序号。

* TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack Number）。例如，主机A发送的当前数据序号是400，数据长度是100，则接收端收到后会返回一个确认号是501的确认号给主机A。

* TCP提供的确认机制，可以在通信过程中可以不对每一个TCP数据包发出单独的确认包（Delayed ACK机制），而是在传送数据时，顺便把确认信息传出，这样可以大大提高网络的利用率和传输效率。同时，TCP的确认机制，也可以一次确认多个数据报，例如，接收方收到了201，301，401的数据报，则只需要对401的数据包进行确认即可，对401的数据包的确认也意味着401之前的所有数据包都已经确认，这样也可以提高系统的效率。

* 若发送方在规定时间内没有收到接收方的确认信息，就要将未被确认的数据包重新发送。接收方如果收到一个有差错的报文，则丢弃此报文，并不向发送方发送确认信息。因此，TCP报文的重传机制是由设置的超时定时器来决定的，在定时的时间内没有收到确认信息，则进行重传。这个定时的时间值的设定非常重要，太大会使包重传的延时比较大，太小则可能没有来得及收到对方的确认包发送方就再次重传，会使网络陷入无休止的重传过程中。接收方如果收到了重复的报文，将会丢弃重复的报文，但是必须发回确认信息，否则对方会再次发送。

* TCP协议应当保证数据报按序到达接收方。如果接收方收到的数据报文没有错误，只是未按序号，这种现象如何处理呢？TCP协议本身没有规定，而是由TCP协议的实现者自己去确定。通常有两种方法进行处理：一是对没有按序号到达的报文直接丢弃，二是将未按序号到达的数据包先放于缓冲区内，等待它前面的序号包到达后，再将它交给应用进程。后一种方法将会提高系统的效率。例如，发送方连续发送了每个报文中100个字节的TCP数据报，其序号分别是1，101，201，…,701。假如其它7个数据报都收到了，而201这个数据报没有收到，则接收端应当对1和101这两个数据报进行确认，并将数据递交给相关的应用进程，301至701这5个数据报则应当放于缓冲区，等到201这个数据报到达后，然后按序将201至701这些数据报递交给相关应用进程，并对701数据报进行确认，确保了应用进程级的TCP数据的按序到达。

![TCP累计确认](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP累计确认.png)

上图是TCP的累计确认机制,在Seq92的ACK丢失的时候,下次的Seq100的ACK中隐含了Seq92的ACK信息.也就是说收到Seq100的ACK说明Seq92也接收成功了.

* TCP没有否定确认机制,接收端只能通过重复确认信息来报告出错情况.

![TCP重发确认帧](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP重发确认帧.png)

TCP中没有否定的ACK,也就是说在Seq101传输失败的时候没有说明失败的ACK,只能通过后续帧的ACK重复传递Seq101的确认帧来表示Seq101传输失败.

* 快速重传:发送检测到三个重发ACK立即重传该ACK所指的段,而不是等待该段超时后再重传.
	* 不足
		* 发送端等待一定时间才能重发可能丢失的段
		* 加剧了端-端的延迟

![TCP快速重传](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP快速重传.png)

发送端收到三次101ACK后,知道Seq101发送失败不等超时立即重发101.

在接受端因为Seq101传送失败导致接收端的数据乱序.接收端可以选择两种方式解决乱序方式.

1. 仅重传超时片段:

这是一种更加保守的方式，仅重传超时的片段，希望其他片段都能够成功接收。如果该片段之后的其他片段实际上接收到了，这一方式是最佳的，如果没接收到，就无法正常执行.

2. 重传所有片段

无论何时一个片段超时了，不仅重传该片段，还有所有其他尚未确认的片段。这一方式确保了任何时间都有一个等待确认的停顿时间，在所有未确认片段丢失的情况下，会刷新全部未确认片段，以使对端设备多一次接收机会.

* 数据丢失的原因
	* 网络拥塞造成途径路由器无缓冲可用,IP包丢失
	* 突发噪声造成偶尔丢包
* 丢失数据后果
	* 已经收到的数据不能立即交给上层应用程序
	* 如果超时值设置不当可能导致双方死锁

#### 流量控制
* 流量控制:用于控制发送端的发送行为,以免快速发送端发送的数据接收端淹没.流量控制仅与发送者和接收者之间的端-端通信有关.
* 接收窗口:接收端根据自己缓冲区大小向发送端通告接收窗口的大小信息.
* 接收端的水桶容量相当于接受缓冲区的容量,接收端根据缓冲区的剩余容量设置返回接收窗口的大小.注意是接收窗口大小是根据缓冲区的剩余容量动态改变的.

* TCP流量控制机制
	* TCP采用大小可变的滑动窗口来控制发送速率
	* 接收端通过window字段反馈当前可接收字节数

![TCPwindow字段](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCPwindow字段.png)

上图是window字段在TCP报文中所在的位置.

![TCP流量控制](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP流量控制.png)

上图是TCP流量控制的简单示例,接收端通过ACK回复发送端一个可接收Window的大小,这个大小根据缓冲区剩余大小来的.发送端收到接收端发送的可接收Window大小来改变自己的发送数据大小.进而达成流量控制.

* TCP发送端维护一个变量"RcvWin"记录接收端能接收的字节数.
	* 大小可变,由收到段的段头中window字段确认
	* LastByteSent:发送端发出的最后一个字节的序号
	* LastByteAckd:发送端从网络接收的最后一个确认序号
	* LastByteSent - LastByteAckd <= RevWin

![TCP流量控制发送端](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP流量控制发送端.png)

* TCP接收端通过端头部的"window"字段给发送端反馈可以接收的字节数.
	* LastByteRead:上层应用程序接收的最后一个字节序号
	* LastByteRcvd:接收端从网络接收的最后一个字节序号
	* 未读取的字节数 = LastByteRcvd - LastByteRead
	* 空闲缓冲区大小 = 总缓冲区长度 - 未读取字节数

![TCP流量控制接收端](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP流量控制接收端.png)

* 发送端优化
	* 将确认(ACK)和窗口更新(window)段延迟一段时间以便打在后续其他数据进行传输.从而提高了发送端的数据传输效率.
	* 避免了传输少量数据.
* 低能窗口综合征
	* 当接收端的应用程序每次仅读取一个字节时
	* 接收端通过一个小的可用窗口值将导致发送端产生短段
	* 发送端的段仅含少量数据
	* 浪费网络带宽,增加计算开销

![TCP低能窗口](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP低能窗口.png)

上图是TCP低能窗口的典型事例,接收缓冲区满,刚空出一个字节就发送窗口更新端,发送端收到接收端发送的窗口更新端发送一个字节数据,接收端收到后又满再次发送窗口更新段给发送端.因为接收端的处理能力低下,导致发送端发送数据很小,但是窗口更新段频繁发出.浪费网络带宽.

* 接收端优化
	* TCP对收到的段进行确认,但要等到接收窗口可用空间达到启发式策略所指定的限度之后才发出窗口增大通告.
	* 在接受窗口大小不够所指定的限度时推迟发送确认.
	* 针对接收端,通过大小为0的window后,要等到接收缓冲区可用空间达到总空间的一半或者MSS之后才发送窗口更新通告.
	* 防止反馈微笑增量值得窗口通告.

#### 拥塞控制

![TCP拥塞控制](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP拥塞控制.png)

* 拥塞窗口(CongWin):大小体现了网络的承受能力.
* 发送端有效窗口必须兼顾网络的传输能力和接收端的接收能力:min(接收窗口,拥塞窗口)
* TCP采用端-端拥塞控制机制:限制发送端通过连接注入网络的流量来缓解拥塞.
	* 连接两端TCP实体以多种方式检测传输路径是否出现拥塞
	* 一旦建设到拥塞立即减少发送速率
	* 拥塞缓解后再逐步增加发送速率
* 如何知晓发送拥塞?
	* 发生丢包事件
		* 段的计时器超时
		* 收到三个重复ACK
	* 路由显示通知
		* 路由器检测到出现拥塞后通知连接一端

![TCP路由显示通知](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP路由显示通知.png)

上图是路由器检测到拥塞后显示通知接收两端.通过CWR标识的报文通知接收端降低发送速率,然后接收端给发送端发送一个ECN标识的报文通知发送端降低发送速率.注意,这里并不是由路由器直接通知发送端降低发送速率,而是先通知接收端,然后由接收端通知发送端.

* 路由器的拥塞检测方法
	* 路由器通过检测出境路线和其他资源的使用情况来推测发送拥塞的可能性
		* 每个路由器周期性的对出境路线的瞬间利用率进行取样f,求得该条线路利用率u
		* 一旦u超过了某个给定阈值,则该条出境线路就进入了警告状态
		* 每新到达一个包,路由器检测出其出境线路的状态
		* 如果该条线路处于警告状态,就意味着可能发生拥塞
	* 当路由器检测出线路利用率接近饱和时,通过显示方式通知发送端降低发送速率.
* TCP如何限制发送速率
	* CongWin:控制TCP发送速率的拥塞窗口
	* RcvWin:接收端通报可以接受的字节数
	* 有效窗口:必须同时兼顾网络和接收端的能力 min(接受窗口,拥塞窗口)
	* RTT:TCP端开始发送到该段ACK返回的时间

![TCP有效窗口](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.TCP有效窗口.png)

![RTT](https://github.com/zzhangyuhang/computer-network/blob/master/photo/8.RTT.png)

* TCP发送端发送速率近似为CongWin/RTT bps
* 发送端通过调整CongWin来限制发送速率